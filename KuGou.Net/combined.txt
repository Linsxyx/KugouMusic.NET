using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

/// <summary>
///     登录响应数据
/// </summary>
public record LoginResponse(
    [property: JsonPropertyName("userid")] string UserId,
    [property: JsonPropertyName("token")] string Token,
    [property: JsonPropertyName("nickname")]
    string? Nickname,
    [property: JsonPropertyName("vip_type")]
    string? VipType,
    [property: JsonPropertyName("vip_token")]
    string? VipToken
)
{
    [JsonExtensionData] public Dictionary<string, object>? ExtraData { get; set; }
}

/// <summary>
///     二维码 Key 响应
/// </summary>
public record QrKeyResponse(
    [property: JsonPropertyName("qrcode_key")]
    string QrCodeKey,
    [property: JsonPropertyName("qrcode_url")]
    string QrCodeUrl
)
{
    [JsonExtensionData] public Dictionary<string, object>? ExtraData { get; set; }
}

/// <summary>
///     二维码状态响应
/// </summary>
public record QrStatusResponse(
    [property: JsonPropertyName("status")] int Status,
    [property: JsonPropertyName("msg")] string? Message,
    [property: JsonPropertyName("userid")] string? UserId,
    [property: JsonPropertyName("token")] string? Token
)
{
    [JsonExtensionData] public Dictionary<string, object>? ExtraData { get; set; }
}

/// <summary>
///     发送验证码响应
/// </summary>
public record SendCodeResponse(
    [property: JsonPropertyName("msg")] string? Message
)
{
    [JsonExtensionData] public Dictionary<string, object>? ExtraData { get; set; }
}

/// <summary>
///     刷新 Token 响应
/// </summary>
/*public record RefreshTokenResponse(
    [property: JsonPropertyName("userid")] string UserId,
    [property: JsonPropertyName("token")] string Token,
    [property: JsonPropertyName("vip_type")]
    string? VipType
)
{
    [JsonExtensionData] public Dictionary<string, object>? ExtraData { get; set; }
}*/using System.Text.Json;
using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

/// <summary>
///     所有模型的基类，自动捕获多余字段
/// </summary>
public abstract record KgBaseModel
{
    [property: JsonPropertyName("status")] public int? Status { get; set; }

    [JsonPropertyName("error_code")] public int? ErrorCode { get; set; }

    [JsonExtensionData] public Dictionary<string, JsonElement>? Extras { get; set; }

    /// <summary>
    ///     方便的辅助方法：从 Extras 里取值
    /// </summary>
    public string? GetExtraString(string key)
    {
        if (Extras != null && Extras.TryGetValue(key, out var val))
            return val.ValueKind == JsonValueKind.String ? val.GetString() : val.ToString();
        return null;
    }
}using System.Text.Json;
using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

/// <summary>
///     最终解析出来的歌词对象
/// </summary>
public class KrcLyric
{
    public List<KrcLine> Lines { get; set; } = new();
    public Dictionary<string, string> MetaData { get; set; } = new();
}

/// <summary>
///     每一行歌词
/// </summary>
public class KrcLine
{
    public long StartTime { get; set; } // 毫秒
    public long Duration { get; set; } // 毫秒
    public string Content { get; set; } = ""; // 原文
    public string Translation { get; set; } = ""; // 翻译
    public string Romanization { get; set; } = ""; // 音译/罗马音
    public List<KrcWord> Words { get; set; } = new(); // 逐字数据
}

/// <summary>
///     逐字歌词详情
/// </summary>
public class KrcWord
{
    public string Text { get; set; } = "";
    public long StartTime { get; set; }
    public long Duration { get; set; }
}

// ============ 下面是用于反序列化 [language:...] JSON 的内部类 ============

internal class LanguageContainer
{
    [JsonPropertyName("content")] public List<LanguageSection>? Content { get; set; }
}

internal class LanguageSection
{
    [JsonPropertyName("type")] public int Type { get; set; } // 1: 翻译, 0: 音译

    // 注意：酷狗返回的 lyricContent 是字符串数组的数组 [ ["第一行翻译"], ["第二行翻译"] ]
    [JsonPropertyName("lyricContent")] public List<List<string>>? LyricContent { get; set; }
}

public record LyricResult(
    string? RawContent,
    string? DecodedContent,
    string? DecodedTranslation,
    JsonElement RawJson
);using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

public record PlaylistInfo : KgBaseModel
{
    // 歌单 ID (listid)
    [property: JsonPropertyName("listid")] public long Id { get; set; }

    // 全局 ID (这是后续调其他接口最常用的)
    [property: JsonPropertyName("global_collection_id")]
    public string GlobalId { get; set; } = "";

    // 歌单名称
    [property: JsonPropertyName("name")] public string Name { get; set; } = "";

    // 封面图片
    [property: JsonPropertyName("pic")] public string PicUrl { get; set; } = "";

    // 简介
    [property: JsonPropertyName("intro")] public string Intro { get; set; } = "";

    // 歌曲总数
    [property: JsonPropertyName("count")] public int SongCount { get; set; }

    // 创建者信息
    [property: JsonPropertyName("list_create_username")]
    public string CreatorName { get; set; } = "";

    [property: JsonPropertyName("list_create_userid")]
    public long CreatorId { get; set; }

    // 播放量 (heat)
    [property: JsonPropertyName("heat")] public int Heat { get; set; }

    // 创建时间 (时间戳)
    [property: JsonPropertyName("create_time")]
    public long CreateTime { get; set; }

    // 其他如 tags, is_publish, status 等会自动进入 Extras
}using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

/// <summary>
///     对应 data 节点的结构
/// </summary>
public record PlaylistSongResponse : KgBaseModel
{
    [JsonPropertyName("count")] public int Count { get; set; }

    [JsonPropertyName("songs")] public List<PlaylistSong> Songs { get; set; } = new();
}

/// <summary>
///     单首歌曲信息 (对应 songs 数组中的项)
/// </summary>
public record PlaylistSong : KgBaseModel
{
    // 歌曲名称 (通常是 "歌手 - 歌名" 格式)
    [property: JsonPropertyName("name")] public string Name { get; set; } = "";

    // 文件 Hash (最重要)
    [property: JsonPropertyName("hash")] public string Hash { get; set; } = "";

    // 时长 (毫秒)
    [property: JsonPropertyName("timelen")]
    public int DurationMs { get; set; }

    // 专辑 ID
    [property: JsonPropertyName("album_id")]
    public string AlbumId { get; set; } = "";

    // 权限/VIP 标记 (10通常是VIP, 0是免费，8可能是版权限制)
    [property: JsonPropertyName("privilege")]
    public int Privilege { get; set; }

    // 歌手信息数组
    [property: JsonPropertyName("singerinfo")]
    public List<SingerLite> Singers { get; set; } = new();

    // 专辑信息对象
    [property: JsonPropertyName("albuminfo")]
    public AlbumLite? Album { get; set; }
}

public record SingerLite : KgBaseModel
{
    [property: JsonPropertyName("id")] public long Id { get; set; }

    [property: JsonPropertyName("name")] public string Name { get; set; } = "";
}

public record AlbumLite : KgBaseModel
{
    [property: JsonPropertyName("id")] public long Id { get; set; } // 这里 JSON 显示是数字，用 long

    [property: JsonPropertyName("name")] public string Name { get; set; } = "";
}using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

public record RefreshTokenResponse : KgBaseModel
{
    [property: JsonPropertyName("userid")] public long UserId { get; set; }
    
    [property: JsonPropertyName("token")] public string Token { get; set; }
    
    [property: JsonPropertyName("is_vip")] public long IsVip { get; set; }
}using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

/// <summary>
///     对应 data 节点的数据
/// </summary>
public record SearchHotResponse
{
    [property: JsonPropertyName("timestamp")]
    public long Timestamp { get; set; }

    // 映射 JSON 中的 "list" 到更具语义的 "Categories"
    [property: JsonPropertyName("list")] public List<SearchHotCategory> Categories { get; set; } = new();
}

/// <summary>
///     榜单分类（如：热搜榜、飙升榜）
/// </summary>
public record SearchHotCategory
{
    [property: JsonPropertyName("name")] public string Name { get; set; } = "";

    [property: JsonPropertyName("keywords")]
    public List<SearchHotKeyword> Keywords { get; set; } = new();
}

/// <summary>
///     具体的热搜关键词项
/// </summary>
public record SearchHotKeyword
{
    [property: JsonPropertyName("keyword")]
    public string Keyword { get; set; } = "";

    [property: JsonPropertyName("reason")] public string Reason { get; set; } = "";

    [property: JsonPropertyName("jumpurl")]
    public string JumpUrl { get; set; } = "";

    [property: JsonPropertyName("json_url")]
    public string JsonUrl { get; set; } = "";

    [property: JsonPropertyName("is_cover_word")]
    public int IsCoverWord { get; set; }

    [property: JsonPropertyName("type")] public int Type { get; set; }

    [property: JsonPropertyName("icon")] public int Icon { get; set; }
}using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

// 1. 搜索结果外层
public record SearchResultData : KgBaseModel
{
    [property: JsonPropertyName("total")] public int Total { get; set; }

    // 注意：有些接口叫 info，有些叫 lists，有些叫 songs
    // 这里我们可以定义多个属性尝试映射，或者在 Client 层处理
    // 假设 V3 接口返回的是 lists
    [property: JsonPropertyName("lists")] public List<SongInfo>? Songs { get; set; }
}

// 2. 歌曲详情 (只定义核心字段)
public record SongInfo : KgBaseModel
{
    // 映射 FileHash 或 Hash
    [property: JsonPropertyName("FileHash")]
    public string Hash { get; set; } = "";

    // 映射 FileName 或 SongName
    [property: JsonPropertyName("FileName")]
    public string Name { get; set; } = "";

    [property: JsonPropertyName("SingerName")]
    public string Singer { get; set; } = "";

    [property: JsonPropertyName("AlbumID")]
    public string AlbumId { get; set; } = "";

    [property: JsonPropertyName("Duration")]
    public int Duration { get; set; }

    // 其他几十个字段（Res, HQ, SQ, MvHash...）全部自动进 Extras
}

// 3. 播放链接结果
public record PlayUrlData : KgBaseModel
{
    [property: JsonPropertyName("url")] public List<string>? Urls { get; set; }

    [property: JsonPropertyName("hash")] public string Hash { get; set; } = "";


    [property: JsonPropertyName("priv_status")]
    public int PrivStatus { get; set; }

    [property: JsonPropertyName("err_code")]
    public int ErrCode { get; set; }

    [JsonIgnore] public bool IsSuccess => Status == 1 && Urls != null && Urls.Count > 0;

    [JsonIgnore] public bool RequiresVip => PrivStatus == 1;

    [JsonIgnore] public bool RequiresAlbumPurchase => PrivStatus == 10;
}using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

public record UserDetailModel : KgBaseModel
{
    [property: JsonPropertyName("nickname")]
    public string Name { get; set; }

    [property: JsonPropertyName("pic")] public string Pic { get; set; }
}

public record OneDayVipModel : KgBaseModel
{
    [property: JsonPropertyName("ad_vip_num")]
    public int AdVipNum { get; set; }

    [property: JsonPropertyName("ad_vip_end_time")]
    public int AdVipEndTime { get; set; }
}

public record UpgradeVipModel : KgBaseModel
{
    [property: JsonPropertyName("recharge_hours")]
    public int RechargeHours { get; set; }
}using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

/// <summary>
///     对应 /v7/get_all_list 接口的 data 节点
/// </summary>
public record UserPlaylistResponse : KgBaseModel
{
    [JsonPropertyName("userid")] public long UserId { get; set; }

    [JsonPropertyName("list_count")] public int ListCount { get; set; }

    // 核心列表数据
    [JsonPropertyName("info")] public List<UserPlaylistItem> Playlists { get; set; } = new();
}

/// <summary>
///     单个用户歌单信息
/// </summary>
public record UserPlaylistItem : KgBaseModel
{
    // 歌单名称
    [JsonPropertyName("name")] public string Name { get; set; } = "";

    // 内部 ID (数字)
    [JsonPropertyName("listid")] public long ListId { get; set; }

    // ★★★ 全局 ID (用于获取歌曲) ★★★
    [JsonPropertyName("global_collection_id")]
    public string GlobalId { get; set; } = "";

    // 歌曲数量
    [JsonPropertyName("count")] public int Count { get; set; }

    // 封面图 (可能为空字符串)
    [JsonPropertyName("pic")] public string Pic { get; set; } = "";

    // 是否默认歌单 (1=默认收藏, 2=我喜欢, 0=自建)
    [JsonPropertyName("is_def")] public int IsDefault { get; set; }

    // 创建时间
    [JsonPropertyName("create_time")] public long CreateTime { get; set; }
}using System.Text.Json.Serialization;

namespace KuGou.Net.Abstractions.Models;

/// <summary>
///     用户 VIP 详情响应
/// </summary>
public record UserVipResponse : KgBaseModel
{
    [JsonPropertyName("userid")] public long UserId { get; set; }

    [JsonPropertyName("is_vip")] public int IsVip { get; set; }

    [JsonPropertyName("vip_type")] public int VipType { get; set; }

    // 核心业务数据：具体的 VIP 类型列表
    [JsonPropertyName("busi_vip")] public List<BusiVipInfo> BusiVipList { get; set; } = new();

    // ================= 辅助属性 (方便业务判断) =================

    /// <summary>
    ///     是否为畅听 VIP (SVIP) - 对应 product_type: "svip"
    /// </summary>
    public bool IsSuperVip => BusiVipList.Any(x =>
        x.ProductType == "svip" && x.IsVip == 1);

    /// <summary>
    ///     是否为概念版 VIP (TVIP) - 对应 product_type: "tvip"
    /// </summary>
    public bool IsConceptVip => BusiVipList.Any(x =>
        x.ProductType == "tvip" && x.IsVip == 1);
}

public record BusiVipInfo
{
    /// <summary>
    ///     是否是 VIP (1: 是, 0: 否)
    /// </summary>
    [JsonPropertyName("is_vip")]
    public int IsVip { get; set; }

    /// <summary>
    ///     VIP 类型标识
    ///     <para>svip = 畅听VIP</para>
    ///     <para>tvip = 概念版VIP</para>
    /// </summary>
    [JsonPropertyName("product_type")]
    public string ProductType { get; set; } = "";

    /// <summary>
    ///     业务类型 (如 "concept")
    /// </summary>
    [JsonPropertyName("busi_type")]
    public string BusiType { get; set; } = "";

    /// <summary>
    ///     开始时间
    /// </summary>
    [JsonPropertyName("vip_begin_time")]
    public string BeginTime { get; set; } = "";

    /// <summary>
    ///     结束时间
    /// </summary>
    [JsonPropertyName("vip_end_time")]
    public string EndTime { get; set; } = "";

    /// <summary>
    ///     清除时间
    /// </summary>
    [JsonPropertyName("vip_clearday")]
    public string ClearDay { get; set; } = "";
}using System.Text.Json;
using System.Text.Json.Serialization.Metadata;
using KuGou.Net.Abstractions.Models;

namespace KuGou.Net.Adapters.Common;

public static class KgApiResponseParser
{
    /// <summary>
    ///     解析响应：校验状态 -> 提取Data -> 反序列化 -> ★回填外层状态★
    ///     <para>AOT 兼容版本</para>
    /// </summary>
    public static T? Parse<T>(JsonElement root, JsonTypeInfo<T> typeInfo)
    {
        // 1. 捕获外层状态 (Root Level Status)
        int? rootStatus = null;
        int? rootErrCode = null;

        if (root.TryGetProperty("status", out var s) && s.ValueKind == JsonValueKind.Number)
            rootStatus = s.GetInt32();

        if (root.TryGetProperty("error_code", out var e) && e.ValueKind == JsonValueKind.Number)
            rootErrCode = e.GetInt32();

        if (rootErrCode == null && root.TryGetProperty("errcode", out var ec) && ec.ValueKind == JsonValueKind.Number)
            rootErrCode = ec.GetInt32();

        var isSuccess = (rootStatus.HasValue && rootStatus.Value == 1) ||
                        (rootErrCode.HasValue && rootErrCode.Value == 0);

        //if (!isSuccess) return default; 

        var targetElement = root;
        if (root.TryGetProperty("data", out var innerData) && innerData.ValueKind != JsonValueKind.Null)
            targetElement = innerData;

        if (typeof(T) == typeof(JsonElement)) return (T)(object)targetElement;

        var result = targetElement.Deserialize(typeInfo);

        if (result is KgBaseModel baseModel)
            if (baseModel.Status == null && rootStatus.HasValue)
                baseModel.Status = rootStatus;

        return result;
    }
}using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using KuGou.Net.Abstractions.Models;

namespace KuGou.Net.Adapters.Lyrics;

public static class KrcParser
{
    /// <summary>
    ///     解析 KRC 文本 (包含翻译和音译提取)
    /// </summary>
    /// <param name="krcText">解密后的 krc 字符串 (decodeContent)</param>
    public static KrcLyric Parse(string krcText)
    {
        var result = new KrcLyric();
        if (string.IsNullOrEmpty(krcText)) return result;

        var lines = krcText.Split(new[] { "\r\n", "\n" }, StringSplitOptions.RemoveEmptyEntries);

        // 临时存储翻译和音译列表
        List<List<string>>? translationList = null;
        List<List<string>>? romanizationList = null;

        // 1. 先提取 [language:...] 标签和其他元数据
        foreach (var line in lines)
        {
            // 匹配 [language:Base64...]
            if (line.StartsWith("[language:"))
            {
                try
                {
                    // 提取 Base64 内容
                    // 格式: [language:Base64String]
                    var base64 = line.Substring(10, line.Length - 11);

                    // 修复 Base64 Padding (JS代码里也做了这步)
                    base64 = base64.Replace("-", "+").Replace("_", "/"); // 有些版本可能是UrlSafe
                    var mod4 = base64.Length % 4;
                    if (mod4 > 0) base64 += new string('=', 4 - mod4);

                    var jsonBytes = Convert.FromBase64String(base64);
                    var jsonStr = Encoding.UTF8.GetString(jsonBytes);

                    var langData = JsonSerializer.Deserialize<LanguageContainer>(jsonStr);

                    if (langData?.Content != null)
                    {
                        // Type 1 = 翻译
                        var transSection = langData.Content.FirstOrDefault(x => x.Type == 1);
                        if (transSection != null) translationList = transSection.LyricContent;

                        // Type 0 = 音译
                        var romSection = langData.Content.FirstOrDefault(x => x.Type == 0);
                        if (romSection != null) romanizationList = romSection.LyricContent;
                    }
                }
                catch
                {
                    // 解析失败忽略，不影响主歌词
                }

                continue;
            }

            // 处理其他元数据 [key:value]
            var metaMatch = Regex.Match(line, @"^\[([a-zA-Z]+):(.*)\]$");
            if (metaMatch.Success)
            {
                var key = metaMatch.Groups[1].Value;
                var val = metaMatch.Groups[2].Value;
                result.MetaData[key] = val;
            }
        }

        // 2. 解析主歌词行 [start,duration]...
        // 正则匹配: [1000,2000]<0,500,0>字<500,300,0>符...
        // 或者是简单的 [1000,2000]歌词内容

        var lineIndex = 0;
        foreach (var line in lines)
        {
            // 跳过元数据行
            if (line.StartsWith("[") && line.Contains(":") && !Regex.IsMatch(line, @"^\[\d+,\d+\]"))
                continue;

            var match = Regex.Match(line, @"^\[(\d+),(\d+)\](.*)");
            if (!match.Success) continue;

            var startTime = long.Parse(match.Groups[1].Value);
            var duration = long.Parse(match.Groups[2].Value);
            var rawContent = match.Groups[3].Value;

            var krcLine = new KrcLine
            {
                StartTime = startTime,
                Duration = duration
            };

            // 解析逐字 <start,len,0>字
            var wordMatches = Regex.Matches(rawContent, @"<(\d+),(\d+),\d+>([^<]+)");
            var sbContent = new StringBuilder();

            if (wordMatches.Count > 0)
                foreach (Match wm in wordMatches)
                {
                    var wStartOffset = long.Parse(wm.Groups[1].Value);
                    var wDuration = long.Parse(wm.Groups[2].Value);
                    var wText = wm.Groups[3].Value;

                    krcLine.Words.Add(new KrcWord
                    {
                        Text = wText,
                        StartTime = startTime + wStartOffset,
                        Duration = wDuration
                    });
                    sbContent.Append(wText);
                }
            else
                // 没有逐字信息，直接取文本
                sbContent.Append(rawContent);

            krcLine.Content = sbContent.ToString();

            // 3. 匹配翻译和音译 (根据行号 index)
            // 翻译
            if (translationList != null && lineIndex < translationList.Count)
            {
                var tLines = translationList[lineIndex];
                if (tLines != null && tLines.Count > 0) krcLine.Translation = tLines[0];
            }

            // 音译 (JS逻辑: join(''))
            if (romanizationList != null && lineIndex < romanizationList.Count)
            {
                var rLines = romanizationList[lineIndex];
                if (rLines != null) krcLine.Romanization = string.Join("", rLines);
            }

            result.Lines.Add(krcLine);
            lineIndex++;
        }

        return result;
    }
}using System.Text.Json;
using KuGou.Net.Abstractions.Models;
using KuGou.Net.Adapters.Common;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.Protocol.Session;
using KuGou.Net.util;

namespace KuGou.Net.Clients;

/// <summary>
///     认证客户端 - 不直接处理 JsonElement，统一使用 KgApiResponseParser 和强类型模型
/// </summary>
public class AuthClient(
    RawLoginApi rawApi,
    KgSessionManager sessionManager
//,ILogger<AuthClient> logger
)
{
    /// <summary>
    ///     发送验证码
    /// </summary>
    public async Task<JsonElement> SendCodeAsync(string mobile)
    {
        var json = await rawApi.SendSmsCodeAsync(mobile);
        return json;
    }

    /// <summary>
    ///     手机验证码登录并保存 Token
    /// </summary>
    public async Task<JsonElement> LoginByMobileAsync(string mobile, string code)
    {
        var json = await rawApi.LoginByMobileAsync(mobile, code);
        if (json.TryGetProperty("data", out var data))
        {
            var newToken = data.GetProperty("token").GetString();
            var newUserId = data.GetProperty("userid").ToString();
            //var vipType = data.GetProperty("is_vip").ToString();

            if (!string.IsNullOrEmpty(newToken))
            {
                sessionManager.UpdateAuth(newUserId, newToken, "0", "");
                KgSessionStore.Save(sessionManager.Session);
                //logger.LogInformation($"Token 登录成功! UserID: {newUserId}");
            }
        }

        //logger.LogWarning("[Auth] 登录 失败，返回数据中未找到 data 节点。");
        return json;
    }

    /// <summary>
    ///     获取二维码 Key 和 URL
    /// </summary>
    public async Task<JsonElement> GetQrCodeAsync()
    {
        var json = await rawApi.GetQrKeyAsync();
        return json;
    }

    /// <summary>
    ///     检查二维码扫码状态
    ///     返回: 0=等待, 1=已扫码, 2=过期, 4=登录成功
    /// </summary>
    public async Task<JsonElement> CheckQrStatusAsync(string key)
    {
        var json = await rawApi.CheckQrStatusAsync(key);

        if (json.TryGetProperty("data", out var data))
        {
            // 修正步骤 2: 从 data 节点中读取字段
            // 注意：userid 和 is_vip 是数字类型，使用 ToString() 最稳妥，能兼容数字和字符串
            var newToken = data.GetProperty("token").GetString();
            var newUserId = data.GetProperty("userid").ToString();

            if (!string.IsNullOrEmpty(newToken))
            {
                sessionManager.UpdateAuth(newUserId, newToken, "0", "");
                KgSessionStore.Save(sessionManager.Session);
                //logger.LogInformation($"Token 刷新成功! UserID: {newUserId}");
            }
        }

        //logger.LogWarning("[Auth] 刷新 Token 失败，返回数据中未找到 data 节点。");
        return json;
    }

    /// <summary>
    ///     刷新 Token (保活)
    /// </summary>
    public async Task<RefreshTokenResponse> RefreshSessionAsync()
    {
        var session = sessionManager.Session;

        // 没 Token 也没 UserID，跳过刷新
        if (string.IsNullOrEmpty(session.Token) || session.UserId == "0")
        {
            Console.WriteLine("[Auth] 本地无有效 Token，跳过刷新。");
            return new RefreshTokenResponse();
        }

        Console.WriteLine($"[Auth] 正在尝试刷新 Token (User: {session.UserId})...");

        // 调用 Raw 接口
        var json = await rawApi.RefreshTokenAsync(session.UserId, session.Token, session.Dfid);
        
        var res = KgApiResponseParser.Parse<RefreshTokenResponse>(json,AppJsonContext.Default.RefreshTokenResponse);

        if (res?.Status==1)
        {
            var newToken = res.Token;
            var newUserId = res.UserId.ToString();
            var vipType = res.IsVip.ToString();

            if (!string.IsNullOrEmpty(newToken))
            {
                sessionManager.UpdateAuth(newUserId, newToken, vipType, "");
                KgSessionStore.Save(sessionManager.Session);
                //logger.LogInformation($"Token 刷新成功! UserID: {newUserId}");
            }
        }
        return res??new RefreshTokenResponse();
    }
    
    
    
    //退出登录
    public async void LogOutAsync()
    {
        KgSessionStore.Clear();
    }
}using System.Text.Json;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.Protocol.Session;
using KuGou.Net.util;

namespace KuGou.Net.Clients;

public class DeviceClient(RawDeviceApi rawApi, KgSessionManager sessionManager)
{
    /// <summary>
    ///     初始化设备 (如果本地没有 DFID 则注册，有则跳过)
    /// </summary>
    public async Task<bool> InitDeviceAsync()
    {
        var session = sessionManager.Session;

        // 1. 检查本地是否已有有效设备信息
        if (!string.IsNullOrEmpty(session.Dfid) && session.Dfid != "-" &&
            !string.IsNullOrEmpty(session.Mid))
            //Console.WriteLine($"[Device] 已有设备信息 DFID: {session.Dfid}");
            return true;

        //Console.WriteLine("[Device] 检测到新设备，开始注册风控信息...");
        return await RegisterDeviceAsync();
    }

    private async Task<bool> RegisterDeviceAsync()
    {
        var session = sessionManager.Session;

        // 1. 生成临时 ID
        var registerDfid = KgUtils.RandomString(24);
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString();

        // 2. 预计算真实的 Mid/Uuid (保存用)
        var localMid = KgUtils.CalcNewMid(registerDfid); // 使用工具类算法
        //var localUuid = KgUtils.Md5(registerDfid + localMid);

        // 3. 调用 Raw API
        var json = await rawApi.RegisterDevAsync(
            session.UserId,
            session.Token,
            registerDfid,
            localMid,
            clientTime
        );

        // 4. 解析结果
        if (json.ValueKind == JsonValueKind.Object &&
            json.TryGetProperty("status", out var statusElem) &&
            statusElem.GetInt32() == 1)
            if (json.TryGetProperty("data", out var dataElem) &&
                dataElem.ValueKind == JsonValueKind.Object &&
                dataElem.TryGetProperty("dfid", out var dfidElem))
            {
                var serverDfid = dfidElem.GetString();

                if (!string.IsNullOrEmpty(serverDfid))
                {
                    session.Dfid = serverDfid;
                    session.Mid = KgUtils.CalcNewMid(serverDfid);
                    session.Uuid = KgUtils.Md5(session.Dfid + session.Mid);

                    KgSessionStore.Save(session);
                    return true;
                }
            }
        return false;
    }
}using System.Text.Json;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.Protocol.Session;

namespace KuGou.Net.Clients;

public class DiscoveryClient(RawDiscoveryApi rawApi, KgSessionManager sessionManager)
{
    private string GetUserId() => sessionManager.Session.UserId == "0" ? "0" : sessionManager.Session.UserId;
    private string GetDfid() => sessionManager.Session.Dfid;

    /// <summary>
    ///     获取推荐歌单
    /// </summary>
    /// <param name="categoryId">分类ID，0=推荐，11292=Hi-Res</param>
    public async Task<JsonElement> GetRecommendedPlaylistsAsync(int categoryId = 0, int page = 1, int pageSize = 30)
    {
        var uid = GetUserId();
        var dfid = GetDfid();
        return await rawApi.GetRecommendedPlaylistsAsync(uid, dfid, categoryId, page, pageSize);
    }

    /// <summary>
    ///     获取新歌速递
    /// </summary>
    /// <param name="type">榜单类型，默认 21608</param>
    public async Task<JsonElement> GetNewSongsAsync(int type = 21608, int page = 1, int pageSize = 30)
    {
        var uid = GetUserId();
        return await rawApi.GetNewSongsAsync(uid, type, page, pageSize);
    }

    /// <summary>
    ///     获取每日推荐歌曲
    /// </summary>
    public async Task<JsonElement> GetRecommendedSongsAsync()
    {
        var uid = GetUserId();
        return await rawApi.GetRecommendSongAsync(uid);
    }
    
    
    public async Task<JsonElement> GetRecommendedStyleSongsAsync()
    {
        return await rawApi.GetRecommendStyleSongAsync();
    }
}using System.Text;
using System.Text.Json;
using KuGou.Net.Abstractions.Models;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.util;
using JsonElement = System.Text.Json.JsonElement;

namespace KuGou.Net.Clients;

public class LyricClient(RawLyricApi rawApi)
{
    /// <summary>
    ///     搜索歌词
    /// </summary>
    public async Task<JsonElement> SearchLyricAsync(string? hash, string? albumAudioId, string? keyword, string? man)
    {
        return await rawApi.SearchLyricAsync(hash, albumAudioId, keyword, man);
    }

    /// <summary>
    ///     获取并解密歌词
    /// </summary>
    /// <param name="decode">是否自动解密 Base64/KRC 内容</param>
    public async Task<LyricResult> GetLyricAsync(
        string id,
        string accessKey,
        string fmt = "krc",
        bool decode = true)
    {
        var json = await rawApi.DownloadLyricAsync(id, accessKey, fmt);

        string? decodedContent = null;
        string? decodedTrans = null;

        if (decode)
        {
            if (json.TryGetProperty("content", out var contentElem)
                && contentElem.ValueKind == JsonValueKind.String)
            {
                var base64 = contentElem.GetString();
                if (!string.IsNullOrEmpty(base64))
                {
                    var contentType = json.TryGetProperty("contenttype", out var t)
                        ? t.GetInt32()
                        : 0;

                    decodedContent =
                        fmt == "lrc" || contentType != 0
                            ? Encoding.UTF8.GetString(Convert.FromBase64String(base64))
                            : KgCrypto.DecodeLyrics(base64);
                }
            }

            if (json.TryGetProperty("trans", out var transElem)
                && transElem.ValueKind == JsonValueKind.String)
                decodedTrans = Encoding.UTF8.GetString(
                    Convert.FromBase64String(transElem.GetString()!)
                );
        }

        return new LyricResult(
            json.GetProperty("content").GetString(),
            decodedContent,
            decodedTrans,
            json
        );
    }
}using System.Text.Json;
using KuGou.Net.Abstractions.Models;
using KuGou.Net.Adapters.Common;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.Protocol.Session;
using KuGou.Net.util;

namespace KuGou.Net.Clients;

public class MusicClient(RawSearchApi rawApi, KgSessionManager sessionManager)
{
    public async Task<List<SongInfo>> SearchAsync(string keyword, int page = 1)
    {
        var json = await rawApi.SearchSongAsync(keyword, page);

        var data = KgApiResponseParser.Parse<SearchResultData>(json, AppJsonContext.Default.SearchResultData);

        if (data?.Songs == null) return new List<SongInfo>();

        return data.Songs;
    }

    public async Task<PlayUrlData?> GetPlayInfoAsync(string hash, string? quality = null)
    {
        var json = await rawApi.GetPlayUrlAsync(hash, quality);

        var result = json.Deserialize(AppJsonContext.Default.PlayUrlData);

        return result ?? new PlayUrlData { Status = 0 };
    }


    public async Task<SearchHotResponse?> GetSearchHotAsync()
    {
        var json = await rawApi.SearchHotAsync();

        var data = KgApiResponseParser.Parse<SearchHotResponse>(
            json,
            AppJsonContext.Default.SearchHotResponse
        );

        return data;
    }


    public async Task<JsonElement> GetSingerSongsAsync(
        string authorId,
        int page = 1,
        int pageSize = 30,
        string sort = "new")
    {
        // 从 Session 获取 DFID
        var dfid = sessionManager.Session.Dfid;

        // 调用 RawApi
        var json = await rawApi.GetSingerSongsAsync(dfid, authorId, page, pageSize, sort);

        return json;
    }
}using System.Text.Json;
using KuGou.Net.Abstractions.Models;
using KuGou.Net.Adapters.Common;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.Protocol.Session;
using KuGou.Net.util;

namespace KuGou.Net.Clients;

public class PlaylistClient(RawPlaylistApi rawApi, KgSessionManager sessionManager)
{
    /// <summary>
    ///     获取歌单内的歌曲列表
    /// </summary>
    public async Task<List<PlaylistSong>> GetSongsAsync(string playlistId, int page = 1, int pageSize = 30)
    {
        // 逻辑搬运：计算起始索引
        var beginIdx = (page - 1) * pageSize;

        var json = await rawApi.GetPlaylistSongsAsync(playlistId, beginIdx, pageSize);
        var data = KgApiResponseParser.Parse<PlaylistSongResponse>(json, AppJsonContext.Default.PlaylistSongResponse);

        return data?.Songs ?? new List<PlaylistSong>();
        //return json;
    }

    /// <summary>
    ///     获取歌单详情（标题、简介、封面等）
    /// </summary>
    public async Task<PlaylistInfo?> GetInfoAsync(string playlistId)
    {
        var session = sessionManager.Session;
        var userid = string.IsNullOrEmpty(session.UserId) ? "0" : session.UserId;
        var token = session.Token ?? "";

        var json = await rawApi.GetPlaylistInfoAsync(playlistId, userid, token);
        var list = KgApiResponseParser.Parse<List<PlaylistInfo>>(json, AppJsonContext.Default.ListPlaylistInfo);
        return list?.FirstOrDefault();
    }


    public async Task<JsonElement?> GetTagsAsync()
    {
        return await rawApi.GetPlaylistTagsAsync();
    }


    private (string UserId, string Token) GetAuth()
    {
        var s = sessionManager.Session;
        if (string.IsNullOrEmpty(s.Token) || s.UserId == "0")
            throw new UnauthorizedAccessException("需要登录后才能操作歌单。");
        return (s.UserId, s.Token);
    }

    /// <summary>
    ///     收藏歌单 / 新建歌单
    ///     <para>对应: /playlist/add</para>
    /// </summary>
    /// <param name="name">歌单名称</param>
    /// <param name="sourceUserId">原歌单创建者ID (收藏时必填)</param>
    /// <param name="sourceListId">原歌单ID (收藏时必填)</param>
    /// <param name="sourceGlobalId">原歌单 GlobalID (可选)</param>
    public async Task<JsonElement?> CollectPlaylistAsync(
        string name,
        string sourceUserId,
        string sourceListId,
        string sourceGlobalId = "",
        long type = 0)
    {
        var (uid, token) = GetAuth();

        // 调用 RawApi
        return await rawApi.CollectPlaylistAsync(uid, token, sourceUserId, sourceListId, sourceGlobalId, name, type);
    }

    /// <summary>
    ///     取消收藏 / 删除歌单
    ///     <para>对应: /playlist/del</para>
    /// </summary>
    /// <param name="listId">用户歌单 ListID (注意不是 GlobalID，是数字ID)</param>
    public async Task<JsonElement?> DeletePlaylistAsync(string listId)
    {
        var (uid, token) = GetAuth();

        return await rawApi.DeletePlaylistAsync(uid, token, listId);
    }

    /// <summary>
    ///     对歌单添加歌曲
    ///     <para>对应: /playlist/tracks/add</para>
    /// </summary>
    /// <param name="targetListId">目标歌单 ListID</param>
    /// <param name="songs">要添加的歌曲列表 (Name, Hash, AlbumId, MixSongId)</param>
    public async Task<JsonElement?> AddSongsAsync(
        string targetListId,
        List<(string Name, string Hash, string AlbumId, string MixSongId)> songs)
    {
        var (uid, token) = GetAuth();

        if (songs == null || songs.Count == 0) return null;

        return await rawApi.AddSongsToPlaylistAsync(uid, token, targetListId, songs);
    }

    /// <summary>
    ///     对歌单删除歌曲
    ///     <para>对应: /playlist/tracks/del</para>
    /// </summary>
    /// <param name="targetListId">目标歌单 ListID</param>
    /// <param name="fileIds">要删除的 FileID 列表 (注意: 这是歌单内的唯一ID，不是歌曲Hash)</param>
    public async Task<JsonElement?> RemoveSongsAsync(string targetListId, IEnumerable<long> fileIds)
    {
        var (uid, token) = GetAuth();

        // 简单的参数校验
        var ids = fileIds.ToList();
        if (ids.Count == 0) return null;

        return await rawApi.RemoveSongsFromPlaylistAsync(uid, token, targetListId, ids);
    }
}using System.Text.Json;
using KuGou.Net.Protocol.Raw;

namespace KuGou.Net.Clients;

public class RankClient(RawRankApi rawApi)
{
    /// <summary>
    ///     获取所有排行榜列表 (飙升榜、Top500、分类榜等)
    ///     <para>对应: /ocean/v6/rank/list</para>
    /// </summary>
    /// <param name="withSong">是否返回榜单下的前几首歌曲预览 (1:返回, 0:不返回)</param>
    public async Task<JsonElement> GetAllRanksAsync(int withSong = 1)
    {
        return await rawApi.GetRankListAsync(withSong);
    }

    /// <summary>
    ///     获取推荐榜单 (通常用于首页展示)
    ///     <para>对应: /mobileservice/api/v5/rank/rec_rank_list</para>
    /// </summary>
    public async Task<JsonElement> GetRecommendedRanksAsync()
    {
        return await rawApi.GetRankTopAsync();
    }

    /// <summary>
    ///     获取某个榜单的具体歌曲列表
    ///     <para>对应: /openapi/kmr/v2/rank/audio</para>
    /// </summary>
    /// <param name="rankId">榜单 ID</param>
    /// <param name="page">页码</param>
    /// <param name="pageSize">每页数量</param>
    /// <param name="rankCid">榜单 CID (可选，部分往期榜单需要)</param>
    public async Task<JsonElement> GetRankSongsAsync(int rankId, int page = 1, int pageSize = 30, int? rankCid = null)
    {
        return await rawApi.GetRankAudioAsync(rankId, rankCid, page, pageSize);
    }

    /// <summary>
    ///     获取排行榜的往期历史 (Vol)
    ///     <para>对应: /ocean/v6/rank/vol</para>
    /// </summary>
    /// <param name="rankId">榜单 ID</param>
    public async Task<JsonElement> GetRankHistoryAsync(int rankId)
    {
        return await rawApi.GetRankVolAsync(rankId);
    }
}using System.Text.Json;
using KuGou.Net.Abstractions.Models;
using KuGou.Net.Adapters.Common;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.Protocol.Session;
using KuGou.Net.util;

namespace KuGou.Net.Clients;

public class UserClient(RawUserApi rawApi, KgSessionManager sessionManager)
{
    private (string UserId, string Token) GetAuth()
    {
        var s = sessionManager.Session;
        return (s.UserId, s.Token);
    }

    private bool IsLoggedIn()
    {
        var s = sessionManager.Session;
        return !string.IsNullOrEmpty(s.Token) && s.UserId != "0";
    }

    /// <summary>
    ///     获取用户详细信息
    /// </summary>
    public async Task<UserDetailModel?> GetUserInfoAsync()
    {
        if (!IsLoggedIn()) return null;
        var (uid, token) = GetAuth();
        var json = await rawApi.GetUserDetailAsync(uid, token);
        return KgApiResponseParser.Parse<UserDetailModel>(json, AppJsonContext.Default.UserDetailModel);
    }

    /// <summary>
    ///     获取用户 VIP 状态
    /// </summary>
    public async Task<UserVipResponse?> GetVipInfoAsync()
    {
        var json = await rawApi.GetUserVipDetailAsync();
        return KgApiResponseParser.Parse<UserVipResponse>(
            json,
            AppJsonContext.Default.UserVipResponse
        );
    }

    /// <summary>
    ///     获取用户歌单
    /// </summary>
    public async Task<List<UserPlaylistItem>> GetPlaylistsAsync(int page = 1, int pageSize = 30)
    {
        if (!IsLoggedIn()) return null;
        var (uid, token) = GetAuth();
        var jsonElement = await rawApi.GetAllListAsync(uid, token, page, pageSize);
        var data = KgApiResponseParser.Parse<UserPlaylistResponse>(jsonElement,
            AppJsonContext.Default.UserPlaylistResponse);

        return data?.Playlists ?? new List<UserPlaylistItem>();
    }

    /// <summary>
    ///     获取听歌历史
    /// </summary>
    public async Task<JsonElement?> GetPlayHistoryAsync(string? bp = null)
    {
        if (!IsLoggedIn()) return null;
        var (uid, token) = GetAuth();
        return await rawApi.GetPlayHistoryAsync(uid, token, bp);
    }

    /// <summary>
    ///     获取听歌排行 (type=0 通常是全部时间)
    /// </summary>
    public async Task<JsonElement?> GetListenRankAsync(int type = 0)
    {
        if (!IsLoggedIn()) return null;
        var (uid, token) = GetAuth();
        return await rawApi.GetListenListAsync(uid, token, type);
    }

    /// <summary>
    ///     获取关注的歌手
    /// </summary>
    public async Task<JsonElement?> GetFollowedSingersAsync()
    {
        if (!IsLoggedIn()) return null;
        var (uid, token) = GetAuth();
        return await rawApi.GetFollowSingerListAsync(uid, token);
    }

    // --- VIP 领取相关 ---

    public async Task<OneDayVipModel?> ReceiveOneDayVipAsync()
    {
        if (!IsLoggedIn()) return null;
        var json = await rawApi.GetOneDayVipAsync();
        return KgApiResponseParser.Parse<OneDayVipModel>(json, AppJsonContext.Default.OneDayVipModel);
    }

    public async Task<UpgradeVipModel?> UpgradeVipRewardAsync()
    {
        if (!IsLoggedIn()) return null;
        var (uid, _) = GetAuth();
        var json = await rawApi.UpgradeVipAsync(uid);
        return KgApiResponseParser.Parse<UpgradeVipModel>(json, AppJsonContext.Default.UpgradeVipModel);
    }
}using System.Text;
using System.Text.Json;
using KuGou.Net.Protocol.Session;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Infrastructure.Http.Handlers;

public class KgSignatureHandler(KgSessionManager sessionManager) : DelegatingHandler
{
    // 文件: KuGou.Net.Infrastructure.Http.Handlers.KgSignatureHandler.cs

    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request,
        CancellationToken cancellationToken)
    {
        if (!request.Options.TryGetValue(new HttpRequestOptionsKey<KgRequest>("KgRequestDetail"), out var kgReq))
            return await base.SendAsync(request, cancellationToken);

        var session = sessionManager.Session;
        var timeStr = DateTimeOffset.UtcNow.ToUnixTimeSeconds().ToString();

        // 1. 准备参数 (保持原有逻辑)
        var currentDfid = kgReq.SpecificDfid ?? session.Dfid;
        var currentMid = kgReq.SpecificDfid != null ? KgUtils.CalcNewMid(currentDfid) : session.Mid;
        var currentUuid = kgReq.SpecificDfid != null ? KgUtils.Md5(currentDfid + currentMid) : session.Uuid;

        var mergedParams = new Dictionary<string, string>(kgReq.Params);

        if (!mergedParams.ContainsKey("appid")) mergedParams["appid"] = KuGouConfig.AppId;
        if (!mergedParams.ContainsKey("clientver")) mergedParams["clientver"] = KuGouConfig.ClientVer;
        if (!mergedParams.ContainsKey("dfid")) mergedParams["dfid"] = currentDfid;
        if (!mergedParams.ContainsKey("mid")) mergedParams["mid"] = currentMid;
        if (!mergedParams.ContainsKey("uuid")) mergedParams["uuid"] = currentUuid;
        if (!mergedParams.ContainsKey("userid")) mergedParams["userid"] = session.UserId;

        // 优先使用 params 里传进来的 clienttime，保证 body 和 url 时间一致
        if (!mergedParams.ContainsKey("clienttime")) mergedParams["clienttime"] = timeStr;

        if (!mergedParams.ContainsKey("token") && !string.IsNullOrEmpty(session.Token))
            mergedParams["token"] = session.Token;

        // V5 Key 计算 (保持不变)
        if (kgReq.SignatureType == SignatureType.V5 && mergedParams.ContainsKey("hash"))
        {
            var paramMid = mergedParams.ContainsKey("mid") ? mergedParams["mid"] : currentMid;
            mergedParams["key"] = KgSigner.CalcV5Key(mergedParams["hash"], mergedParams["userid"], paramMid);
        }

        // 2. 统一处理 Body 序列化 (POST 请求需要 Body 参与签名)
        var jsonBody = "";
        if (request.Method == HttpMethod.Post && kgReq.Body != null && kgReq.Body.Count > 0)
        {
            // 序列化
            jsonBody = JsonSerializer.Serialize(kgReq.Body, AppJsonContext.Default.JsonObject);

            // 设置 HTTP Content
            request.Content = new StringContent(jsonBody, Encoding.UTF8, "application/json");
        }
        // 处理 RawBody (如注册接口)
        else if (request.Method == HttpMethod.Post && !string.IsNullOrEmpty(kgReq.RawBody))
        {
            jsonBody = kgReq.RawBody;
            // RawBody 通常已经是 Base64 或 JSON 字符串，不需要再次序列化
        }

        // 3. 计算签名 (关键修复：移出 else 块，POST/GET 通用)
        var signature = "";
        if (kgReq.SignatureType == SignatureType.Web)
            signature = KgSigner.CalcWebQrSignature(mergedParams);
        else if (kgReq.SignatureType != SignatureType.None)
            // Post 签名需要包含 Body 字符串
            signature = KgSigner.CalcPostSignature(mergedParams, jsonBody);

        if (!string.IsNullOrEmpty(signature)) mergedParams["signature"] = signature;

        // 4. 重建 URL (包含签名)
        var queryString = string.Join("&", mergedParams.Select(x => $"{x.Key}={Uri.EscapeDataString(x.Value)}"));
        var uriBuilder = new UriBuilder(request.RequestUri!) { Query = queryString };
        request.RequestUri = uriBuilder.Uri;

        // 5. 设置 Headers
        if (!string.IsNullOrEmpty(kgReq.SpecificRouter))
            request.Headers.TryAddWithoutValidation("x-router", kgReq.SpecificRouter);

        request.Headers.TryAddWithoutValidation("User-Agent", KuGouConfig.UserAgent);
        request.Headers.TryAddWithoutValidation("dfid", currentDfid);
        request.Headers.TryAddWithoutValidation("mid", currentMid);
        // 确保 Header 里的 clienttime 和 URL 参数里的一致
        request.Headers.TryAddWithoutValidation("clienttime", mergedParams["clienttime"]);

        return await base.SendAsync(request, cancellationToken);
    }
}using System.Net;
using KuGou.Net.Infrastructure.Http.Handlers;
using KuGou.Net.Protocol.Session;

namespace KuGou.Net.Infrastructure.Http;

/// <summary>
///     负责组装 HttpClient 的工厂。
///     既可以在非 DI 环境下手动创建 Transport，也可以包含 DI 的配置逻辑。
/// </summary>
public static class KgHttpClientFactory
{
    public static (IKgTransport Transport, KgSessionManager Session) CreateWithSession()
    {
        var cookieContainer = new CookieContainer();
        var sessionManager = new KgSessionManager(cookieContainer);

        // 调用之前的 Create 方法 (假设你保留了 Create(KgSessionManager existing))
        var transport = Create(sessionManager);

        return (transport, sessionManager);
    }

    /// <summary>
    ///     [非 DI 模式] 手动创建一个配置好的 Transport。
    ///     自动组装 CookieContainer -> SessionManager -> SignatureHandler -> HttpClient
    /// </summary>
    /// <param name="existingSession">如果需要在多个 Client 间共享 Session，可传入已有的 SessionManager</param>
    /// <returns>配置好的传输层对象</returns>
    public static IKgTransport Create(KgSessionManager? existingSession = null)
    {
        // 1. 准备底层组件
        // 如果没有传入 SessionManager，则全新创建一个（包含新的 CookieContainer）
        var cookieContainer = new CookieContainer();
        var sessionManager = existingSession ?? new KgSessionManager(new CookieContainer());

        // 2. 配置最底层的 HttpClientHandler
        var primaryHandler = new HttpClientHandler
        {
            UseCookies = true,
            CookieContainer = cookieContainer, // 绑定 Cookie 容器
            AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate,
            ServerCertificateCustomValidationCallback = delegate { return true; } // (可选) 跳过 SSL 验证，抓包用
        };

        // 3. 组装中间件 (Handler Chain)
        // 顺序：Request -> SignatureHandler -> HttpClientHandler -> Network
        var signatureHandler = new KgSignatureHandler(sessionManager)
        {
            InnerHandler = primaryHandler // ★★★ 关键：手动连接 Handler 链
        };

        // 4. 创建 HttpClient
        // 注意：在非 DI 模式下，这个 HttpClient 应该被长期持有，不要频繁创建
        var httpClient = new HttpClient(signatureHandler);

        // 配置一些全局默认头
        httpClient.DefaultRequestHeaders.Connection.Add("keep-alive");

        // 5. 返回封装好的 Transport
        return new KgHttpTransport(httpClient);
    }
}using System.Text;
using System.Text.Json;
using System.Text.Json.Nodes;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Infrastructure.Http;

public interface IKgTransport
{
    Task<JsonElement> SendAsync(KgRequest request);
}

public class KgHttpTransport(HttpClient client) : IKgTransport
{
    public async Task<JsonElement> SendAsync(KgRequest request)
    {
        var baseUrl = request.BaseUrl ?? "https://gateway.kugou.com";
        var urlBuilder = new StringBuilder($"{baseUrl.TrimEnd('/')}/{request.Path.TrimStart('/')}");

        if (request.Params != null && request.Params.Count > 0)
        {
            urlBuilder.Append('?');
            var queryString = string.Join("&", request.Params.Select(kv =>
                $"{kv.Key}={Uri.EscapeDataString(kv.Value)}"));
            urlBuilder.Append(queryString);
        }

        using var msg = new HttpRequestMessage(request.Method, urlBuilder.ToString());
        msg.Options.Set(new HttpRequestOptionsKey<KgRequest>("KgRequestDetail"), request);

        if (request.CustomHeaders != null)
            foreach (var kv in request.CustomHeaders)
                msg.Headers.TryAddWithoutValidation(kv.Key, kv.Value);

        if (request.Method == HttpMethod.Post)
        {
            if (!string.IsNullOrEmpty(request.RawBody))
            {
                msg.Content = new StringContent(request.RawBody, Encoding.UTF8, request.ContentType);
            }
            else if (request.Body != null)
            {
                var jsonBody = JsonSerializer.Serialize(
                    request.Body,
                    AppJsonContext.Default.JsonObject
                );
                msg.Content = new StringContent(jsonBody, Encoding.UTF8, "application/json");
            }
        }

        using var response = await client.SendAsync(msg);
        response.EnsureSuccessStatusCode();

        // ========== 修改开始：增强的响应处理逻辑 ==========

        // 1. 先读取为字节数组 (比 ReadAsStreamAsync 更安全，因为我们需要重复尝试)
        var responseBytes = await response.Content.ReadAsByteArrayAsync();

        if (responseBytes.Length == 0)
            // 空响应，返回空对象
            return JsonSerializer.Deserialize<JsonElement>("{}");

        try
        {
            // 2. 尝试作为标准 JSON 解析
            using var doc = JsonDocument.Parse(responseBytes);
            return doc.RootElement.Clone();
        }
        catch (JsonException)
        {
            // 3. 解析失败（说明是二进制数据或非 JSON 字符串）
            // 我们将其转换为 Base64，并包裹在一个临时 JSON 对象中返回
            // 这样上层 API 就可以通过提取 "__raw_base64__" 字段来获取原始数据
            var base64Content = Convert.ToBase64String(responseBytes);

            var fallbackJson = new JsonObject
            {
                ["__raw_base64__"] = base64Content
            };

            // 序列化回 JsonElement
            var fallbackDoc = JsonSerializer.SerializeToElement(fallbackJson, AppJsonContext.Default.JsonObject);
            return fallbackDoc;
        }
        // ========== 修改结束 ==========
    }
}using System.Net;
using KuGou.Net.Clients;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Infrastructure.Http.Handlers;
using KuGou.Net.Protocol.Raw;
using KuGou.Net.Protocol.Session;
using Microsoft.Extensions.DependencyInjection;

namespace KuGou.Net.Infrastructure;

public static class KuGouServiceCollectionExtensions
{
    public static IServiceCollection AddKuGouSdk(this IServiceCollection services)
    {
        // 1. 注册核心状态管理 (必须是单例 Singleton)
        // 这样整个 WebAPI 运行期间，内存里只有一份 Session，登录一次，所有接口共享
        services.AddSingleton<CookieContainer>();
        services.AddSingleton<KgSessionManager>();

        // 2. 注册签名拦截器 (Transient)
        services.AddTransient<KgSignatureHandler>();

        // 3. 注册 HTTP 传输层 (使用 HttpClientFactory)
        services.AddHttpClient<IKgTransport, KgHttpTransport>()
            .ConfigurePrimaryHttpMessageHandler(sp =>
            {
                var cookieContainer = sp.GetRequiredService<CookieContainer>();
                return new HttpClientHandler
                {
                    UseCookies = true,
                    CookieContainer = cookieContainer, // 绑定单例的 Cookie 容器
                    AutomaticDecompression = DecompressionMethods.GZip | DecompressionMethods.Deflate,
                    ServerCertificateCustomValidationCallback = delegate { return true; } // 忽略 SSL 错误
                };
            })
            .AddHttpMessageHandler<KgSignatureHandler>(); // ★★★ 自动挂载签名拦截器

        // 4. 注册 Raw API (可以是 Transient 或 Scoped)
        services.AddTransient<RawSearchApi>();
        services.AddTransient<RawLoginApi>();
        services.AddTransient<RawPlaylistApi>();
        services.AddTransient<RawUserApi>();
        services.AddTransient<RawDeviceApi>();
        services.AddTransient<RawLyricApi>();
        services.AddTransient<RawRankApi>();
        
        services.AddTransient<RawDiscoveryApi>();

        // 2. 注册 DiscoveryClient
        services.AddTransient<DiscoveryClient>();

        // 5. 注册 高级 Clients (可以是 Transient 或 Scoped)
        
        services.AddTransient<RankClient>(); 
        services.AddTransient<MusicClient>();
        services.AddTransient<AuthClient>();
        services.AddTransient<PlaylistClient>();
        services.AddTransient<UserClient>();
        services.AddTransient<DeviceClient>();
        services.AddTransient<LyricClient>();

        return services;
    }
}using System.Text;
using System.Text.Json;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

// 引用原有工具类

namespace KuGou.Net.Protocol.Raw;

public class RawDeviceApi(IKgTransport transport)
{
    private const string RegisterSalt = "1014";

    /// <summary>
    ///     注册设备获取 DFID
    /// </summary>
    public async Task<JsonElement> RegisterDevAsync(
        string userId,
        string token,
        string tempDfid,
        string localMid,
        string clientTime)
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "appid", "1014" },
            { "clientver", KuGouConfig.ClientVer },
            { "clienttime", clientTime },
            { "dfid", tempDfid },
            { "mid", "" }, // 必须传空
            { "uuid", "" }, // 必须传空
            { "userid", userId },
            { "p.token", "" }, // 必须传空
            { "platid", "4" }
        };

        if (!string.IsNullOrEmpty(token)) paramsDict["token"] = token;

        paramsDict["signature"] = CalcRegisterSignature(paramsDict);

        // 3. 准备 Body (JSON -> Base64)
        var bodyObj = new Dictionary<string, string>
        {
            ["mid"] = "",
            ["uuid"] = "",
            ["appid"] = "1014",
            ["userid"] = userId
        };
        var bodyJson = JsonSerializer.Serialize(bodyObj);
        var bodyBase64 = Convert.ToBase64String(Encoding.UTF8.GetBytes(bodyJson));

        // 4. 构造请求
        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            BaseUrl = "https://userservice.kugou.com",
            Path = "/risk/v1/r_register_dev",
            Params = paramsDict,
            RawBody = bodyBase64,
            ContentType = "text/plain",
            SignatureType = SignatureType.None
        };


        request.SpecificDfid = tempDfid;

        return await transport.SendAsync(request);
    }

    private static string CalcRegisterSignature(Dictionary<string, string> paramsDict)
    {
        var values = new List<string>();
        foreach (var kv in paramsDict) values.Add(kv.Value);

        values.Sort();

        var valuesString = string.Join("", values);

        return KgUtils.Md5($"{RegisterSalt}{valuesString}{RegisterSalt}");
    }
}using System.Text.Json;
using System.Text.Json.Nodes;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Protocol.Raw;

public class RawDiscoveryApi(IKgTransport transport)
{
    /// <summary>
    ///     获取推荐歌单
    /// </summary>
    /// <param name="categoryId">0: 推荐, 11292: HI-RES</param>
    public async Task<JsonElement> GetRecommendedPlaylistsAsync(
        string userid,
        string dfid,
        int categoryId = 0,
        int page = 1,
        int pageSize = 30)
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        
        // 1. 计算特殊 Key (JS: signParamsKey)
        // 逻辑通常是: md5(appid + salt + clientver + time)
        // 这里复用 KgSigner.CalcLoginKey 的逻辑，因为算法一致
        var key = KgSigner.CalcLoginKey(clientTime);

        // 2. 计算 mid (JS: cryptoMd5(dfid))
        var mid = KgUtils.Md5(string.IsNullOrEmpty(dfid) ? "-" : dfid);

        // 3. 构建内部对象 special_recommend
        var specialRecommend = new JsonObject
        {
            ["withtag"] = 1,
            ["withsong"] = 1,
            ["sort"] = 1,
            ["ugc"] = 1,
            ["is_selected"] = 0,
            ["withrecommend"] = 1,
            ["area_code"] = 1,
            ["categoryid"] = categoryId
        };

        // 4. 构建主 Body
        var body = new JsonObject
        {
            ["appid"] = KuGouConfig.AppId,
            ["mid"] = mid,
            ["clientver"] = KuGouConfig.ClientVer,
            ["platform"] = "android",
            ["clienttime"] = clientTime,
            ["userid"] = userid,
            ["module_id"] = 1,
            ["page"] = page,
            ["pagesize"] = pageSize,
            ["key"] = key,
            ["special_recommend"] = specialRecommend,
            ["req_multi"] = 1,
            ["retrun_min"] = 5,
            ["return_special_falg"] = 1
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/v2/special_recommend",
            Body = body,
            SpecificRouter = "specialrec.service.kugou.com",
            SignatureType = SignatureType.Default 
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     新歌速递
    /// </summary>
    /// <param name="rankId">默认 21608 (华语新歌?)</param>
    public async Task<JsonElement> GetNewSongsAsync(
        string userid,
        int rankId = 21608,
        int page = 1,
        int pageSize = 30)
    {
        var body = new JsonObject
        {
            ["rank_id"] = rankId,
            ["userid"] = userid,
            ["page"] = page,
            ["pagesize"] = pageSize,
            ["tags"] = new JsonArray() 
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/musicadservice/container/v1/newsong_publish",
            Body = body,
            SignatureType = SignatureType.Default 
        };

        return await transport.SendAsync(request);
    }
    
    
    /// <summary>
    ///     获取每日推荐
    /// </summary>
    public async Task<JsonElement> GetRecommendSongAsync(string? userid)
    {
        var body = new JsonObject
        {
            ["platform"] = "android",
            ["userid"] = userid ?? "0"
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/everyday_song_recommend",
            Body = body,
            SignatureType = SignatureType.Default,
            SpecificRouter = "everydayrec.service.kugou.com"
        };
        return await transport.SendAsync(request);
    }
    
    
    
    /// <summary>
    ///     获取每日风格推荐
    /// </summary>
    public async Task<JsonElement> GetRecommendStyleSongAsync()
    {
        var body = new JsonObject
        {
            ["platform"] = "android",
        };
        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/everydayrec.service/everyday_style_recommend",
            Body = body,
            SignatureType = SignatureType.Default,
            Params = new Dictionary<string, string>
            {
                {"tagids",""},
            },
        };
        return await transport.SendAsync(request);
    }
    
    
    
    
}using System.Text.Json;
using System.Text.Json.Nodes;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Protocol.Raw;

public class RawLoginApi(IKgTransport transport)
{
    private const string ApiHost = "http://login.user.kugou.com";
    private const string LoginRouter = "login.user.kugou.com";
    private const string WebHost = "https://login-user.kugou.com";

    /// <summary>
    ///     手机验证码登录 (对应原 LoginByMobileAsync)
    /// </summary>
    public async Task<JsonElement> LoginByMobileAsync(string mobile, string code)
    {
        var isLite = true;
        var dateTime = DateTimeOffset.Now.ToUnixTimeMilliseconds();

        var aesPayload = new JsonObject
        {
            ["mobile"] = mobile,
            ["code"] = code
        };
        var aesJson = JsonSerializer.Serialize(aesPayload, AppJsonContext.Default.JsonObject);
        var (aesStr, aesKey) = KgCrypto.AesEncrypt(aesJson);

        var dataMap = new JsonObject
        {
            ["plat"] = 1,
            ["support_multi"] = 1,
            ["t1"] = 0,
            ["t2"] = 0,
            ["clienttime_ms"] = dateTime,
            ["key"] = KgSigner.CalcLoginKey(dateTime) // 原有的 Signer
        };

        if (isLite)
        {
            dataMap["mobile"] = mobile;
            var p2Data = new JsonObject
            {
                ["clienttime_ms"] = dateTime,
                ["code"] = code,
                ["mobile"] = mobile
            };
            var p2Json = JsonSerializer.Serialize(p2Data, AppJsonContext.Default.JsonObject);
            dataMap["p2"] = KgCrypto.RsaEncryptNoPadding(p2Json).ToUpper();
        }
        else
        {
            var maskedMobile = mobile.Length > 10
                ? $"{mobile[..2]}*****{mobile.Substring(10, 1)}"
                : mobile;

            dataMap["mobile"] = maskedMobile;
            dataMap["t3"] = "MCwwLDAsMCwwLDAsMCwwLDA=";
            dataMap["params"] = aesStr;

            var pkData = new JsonObject
            {
                ["clienttime_ms"] = dateTime,
                ["key"] = aesKey
            };
            dataMap["pk"] = KgCrypto.RsaEncryptNoPadding(JsonSerializer.Serialize(pkData))
                .ToUpper();
        }

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            BaseUrl = ApiHost,
            Path = isLite ? "/v6/login_by_verifycode" : "/v7/login_by_verifycode",
            SpecificRouter = LoginRouter,
            Body = dataMap,
            SignatureType = SignatureType.Default
        };

        var response = await transport.SendAsync(request);

        string? decrypted = null;

        if (response.TryGetProperty("data", out var dataElem)
            && dataElem.ValueKind == JsonValueKind.Object
            && dataElem.TryGetProperty("secu_params", out var secuElem)
            && secuElem.ValueKind == JsonValueKind.String)
            try
            {
                decrypted = KgCrypto.AesDecrypt(secuElem.GetString()!, aesKey);
            }
            catch
            {
                // log
            }

        return response;
    }

    /// <summary>
    ///     发送验证码
    /// </summary>
    public async Task<JsonElement> SendSmsCodeAsync(string mobile)
    {
        var body = new JsonObject
        {
            ["businessid"] = 5,
            ["mobile"] = mobile,
            ["plat"] = 3
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            BaseUrl = ApiHost,
            Path = "/v7/send_mobile_code",
            SpecificRouter = LoginRouter,
            Body = body,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }


    /// <summary>
    ///     A. 获取二维码及 Key
    /// </summary>
    public async Task<JsonElement> GetQrKeyAsync()
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "appid", "1001" }, // Web 端 AppId
            { "clientver", "11040" },
            { "type", "1" },
            { "plat", "4" },
            { "srcappid", "2919" },
            { "qrcode_txt", "https://h5.kugou.com/apps/loginQRCode/html/index.html?appid=3116&" }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            BaseUrl = WebHost,
            Path = "/v2/qrcode",
            Params = paramsDict,
            SignatureType = SignatureType.Web
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     B. 检查二维码状态 (轮询用)
    /// </summary>
    public async Task<JsonElement> CheckQrStatusAsync(string key)
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "plat", "4" },
            { "appid", "3116" },
            { "srcappid", "2919" },
            { "qrcode", key }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            BaseUrl = WebHost,
            Path = "/v2/get_userinfo_qrcode",
            Params = paramsDict,
            SignatureType = SignatureType.Web
        };

        return await transport.SendAsync(request);
    }


    /// <summary>
    ///     刷新 Token (核心逻辑搬运)
    /// </summary>
    public async Task<JsonElement> RefreshTokenAsync(string userid, string token, string dfid)
    {
        const string fixedKey = "c24f74ca2820225badc01946dba4fdf7";
        const string fixedIv = "adc01946dba4fdf7";

        var dateNow = DateTimeOffset.Now.ToUnixTimeMilliseconds();
        var clienttimeSec = dateNow / 1000;

        var p3Data = new JsonObject
        {
            ["clienttime"] = clienttimeSec,
            ["token"] = token
        };
        var p3Json = JsonSerializer.Serialize(p3Data, AppJsonContext.Default.JsonObject);
        var (p3Encrypted, _) = KgCrypto.AesEncrypt(p3Json, fixedKey, fixedIv);

        var (paramsEncrypted, randomAesKey) = KgCrypto.AesEncrypt("{}");

        var pkPayload = new JsonObject
        {
            ["clienttime_ms"] = dateNow,
            ["key"] = randomAesKey
        };
        var pkJson = JsonSerializer.Serialize(pkPayload, AppJsonContext.Default.JsonObject);
        var pk = KgCrypto.RsaEncryptNoPadding(pkJson).ToUpper();

        var body = new JsonObject
        {
            ["dfid"] = dfid,
            ["p3"] = p3Encrypted,
            ["plat"] = 1,
            ["t1"] = 0,
            ["t2"] = 0,
            ["t3"] = "MCwwLDAsMCwwLDAsMCwwLDA=",
            ["pk"] = pk,
            ["params"] = paramsEncrypted,
            ["userid"] = userid,
            ["clienttime_ms"] = dateNow
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            BaseUrl = ApiHost,
            Path = "/v4/login_by_token",
            SpecificRouter = LoginRouter,
            Body = body,
            SignatureType = SignatureType.Default
        };

        var response = await transport.SendAsync(request);

        try
        {
            var rootNode = JsonNode.Parse(response.GetRawText());
            if (rootNode is JsonObject rootObj &&
                rootObj["status"]?.GetValue<int>() == 1 &&
                rootObj["data"] is JsonObject dataObj)
                if (dataObj["secu_params"] is JsonValue secuVal)
                    try
                    {
                        var decryptedJson = KgCrypto.AesDecrypt(
                            secuVal.ToString(),
                            fixedKey
                        );
                        var decryptedNode = JsonNode.Parse(decryptedJson);
                        if (decryptedNode is JsonObject decryptedObj)
                            foreach (var kv in decryptedObj)
                                dataObj[kv.Key] = kv.Value?.DeepClone();

                        return JsonSerializer.SerializeToElement(rootNode);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"[RawLoginApi] 解密/合并失败: {ex.Message}");
                        // 如果解密失败，就返回原始 response
                    }
        }
        catch
        {
            // 解析异常忽略，返回原样
        }

        return response;
    }
}using System.Text.Json;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Protocol.Raw;

public class RawLyricApi(IKgTransport transport)
{
    private const string LyricHost = "https://lyrics.kugou.com";

    /// <summary>
    ///     搜索歌词 (获取 id 和 accesskey)
    /// </summary>
    public async Task<JsonElement> SearchLyricAsync(string? hash, string? albumAudioId, string? keyword, string? man)
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "album_audio_id", albumAudioId ?? "0" },
            { "appid", KuGouConfig.AppId },
            { "clientver", KuGouConfig.ClientVer },
            { "duration", "0" },
            { "hash", hash ?? "" },
            { "keyword", keyword ?? "" },
            { "lrctxt", "1" },
            { "man", man ?? "no" }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            BaseUrl = LyricHost,
            Path = "/v1/search",
            Params = paramsDict,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     下载歌词 (获取 content 字段)
    /// </summary>
    public async Task<JsonElement> DownloadLyricAsync(string id, string accessKey, string fmt = "krc")
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "ver", "1" },
            { "client", "android" },
            { "id", id },
            { "accesskey", accessKey },
            { "fmt", fmt },
            { "charset", "utf8" }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            BaseUrl = LyricHost,
            Path = "/download",
            Params = paramsDict,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }
}using System.Text.Json;
using System.Text.Json.Nodes;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Protocol.Raw;

public class RawPlaylistApi(IKgTransport transport)
{
    /// <summary>
    ///     获取歌单内歌曲 (对应 /pubsongs/v2/get_other_list_file_nofilt)
    /// </summary>
    /// <param name="beginIdx">注意：这里传的是起始索引，不是页码</param>
    public async Task<JsonElement> GetPlaylistSongsAsync(string playlistId, int beginIdx, int pageSize)
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "area_code", "1" },
            { "begin_idx", beginIdx.ToString() },
            { "plat", "1" },
            { "type", "1" },
            { "mode", "1" },
            { "personal_switch", "1" },
            { "extend_fields", "abtags,hot_cmt,popularization" },
            { "pagesize", pageSize.ToString() },
            { "global_collection_id", playlistId }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            Path = "/pubsongs/v2/get_other_list_file_nofilt",
            Params = paramsDict,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取歌单详情信息 (对应 /v3/get_list_info)
    /// </summary>
    public async Task<JsonElement> GetPlaylistInfoAsync(string playlistId, string userid, string token)
    {
        var innerItem = new JsonObject
        {
            ["global_collection_id"] = playlistId
        };

        var dataArray = new JsonArray
        {
            innerItem
        };
        var body = new JsonObject
        {
            ["data"] = dataArray,
            ["userid"] = userid,
            ["token"] = token
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/v3/get_list_info",
            Body = body,
            SpecificRouter = "pubsongs.kugou.com",
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }


    /// <summary>
    ///     收藏创建歌单
    /// </summary>
    /// <param name="listCreateUserId">原歌单创建者ID</param>
    /// <param name="listCreateListId">原歌单ID (数字)</param>
    /// <param name="listCreateGid">原歌单 Global ID</param>
    /// <param name="name">歌单名称</param>
    /// <param name="type">0: 创建 1：收藏</param>
    public async Task<JsonElement> CollectPlaylistAsync(
        string userid,
        string token,
        string listCreateUserId,
        string listCreateListId,
        string listCreateGid,
        string name,
        long? type)
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

        // 构建 Body
        var body = new JsonObject
        {
            ["userid"] = userid,
            ["token"] = token,
            ["total_ver"] = 0,
            ["name"] = name,
            ["type"] = type ?? 0,
            ["source"] = 1,
            ["is_pri"] = 0,
            ["list_create_userid"] = listCreateUserId,
            ["list_create_listid"] = listCreateListId,
            ["list_create_gid"] = listCreateGid ?? "",
            ["from_shupinmv"] = 0
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/cloudlist.service/v5/add_list",
            Params = new Dictionary<string, string>
            {
                { "last_time", clientTime.ToString() },
                { "last_area", "gztx" },
                { "userid", userid },
                { "token", token }
            },
            Body = body,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     取消收藏/删除歌单
    /// </summary>
    public async Task<JsonElement> DeletePlaylistAsync(string userid, string token, string listid)
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

        var dataMap = new JsonObject
        {
            ["listid"] = long.Parse(listid),
            ["total_ver"] = 0,
            ["type"] = 1
        };
        var (aesStr, aesKey) = KgCrypto.PlaylistAesEncrypt(dataMap);
        var keyPayload = new JsonObject
        {
            ["aes"] = aesKey,
            ["uid"] = userid,
            ["token"] = token
        };
        var keyPayloadJson = JsonSerializer.Serialize(keyPayload, AppJsonContext.Default.JsonObject);
        var p = KgCrypto.RsaEncryptPkcs1(keyPayloadJson).ToUpper();

        var signKeyRaw = $"{KuGouConfig.AppId}{KuGouConfig.LiteSalt}{KuGouConfig.ClientVer}{clientTime}";
        var signKey = KgUtils.Md5(signKeyRaw);
        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/v2/delete_list",
            Params = new Dictionary<string, string>
            {
                { "clienttime", clientTime.ToString() },
                { "key", signKey },
                { "last_area", "gztx" },
                { "clientver", KuGouConfig.ClientVer },
                { "appid", KuGouConfig.AppId },
                { "last_time", clientTime.ToString() },
                { "p", p }
            },
            RawBody = aesStr,
            ContentType = "text/plain",
            SpecificRouter = "cloudlist.service.kugou.com",
            SignatureType = SignatureType.Default
        };
        var response = await transport.SendAsync(request);

        try
        {
            string? encryptedResponse = null;
            if (response.ValueKind == JsonValueKind.Object &&
                response.TryGetProperty("__raw_base64__", out var rawEl))
                encryptedResponse = rawEl.GetString();
            else if (response.ValueKind == JsonValueKind.Object &&
                     response.TryGetProperty("data", out var dataEl))
                encryptedResponse = dataEl.GetString();
            else if (response.ValueKind == JsonValueKind.String) encryptedResponse = response.GetString();

            if (!string.IsNullOrEmpty(encryptedResponse))
            {
                var decryptedJson = KgCrypto.PlaylistAesDecrypt(encryptedResponse, aesKey);

                using var doc = JsonDocument.Parse(decryptedJson);
                return doc.RootElement.Clone();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[DeletePlaylist] 解密响应失败: {ex.Message}");
        }

        return response;
    }

    /// <summary>
    ///     获取歌单分类
    /// </summary>
    public async Task<JsonElement> GetPlaylistTagsAsync()
    {
        var body = new JsonObject
        {
            ["tag_type"] = "collection",
            ["tag_id"] = 0,
            ["source"] = 3
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/pubsongs/v1/get_tags_by_type",
            Body = body,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     向歌单添加歌曲
    /// </summary>
    /// <param name="songs">歌曲列表，每项格式: { Name, Hash, AlbumId, MixSongId }</param>
    public async Task<JsonElement> AddSongsToPlaylistAsync(
        string userid,
        string token,
        string listid,
        List<(string Name, string Hash, string AlbumId, string MixSongId)> songs)
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

        // 构建 resources 数组
        var resourceArray = new JsonArray();
        foreach (var song in songs)
            resourceArray.Add(new JsonObject
            {
                ["number"] = 1,
                ["name"] = song.Name ?? "",
                ["hash"] = song.Hash ?? "",
                ["size"] = 0,
                ["sort"] = 0,
                ["timelen"] = 0,
                ["bitrate"] = 0,
                ["album_id"] = long.TryParse(song.AlbumId, out var aid) ? aid : 0,
                ["mixsongid"] = long.TryParse(song.MixSongId, out var mid) ? mid : 0
            });

        var body = new JsonObject
        {
            ["userid"] = userid,
            ["token"] = token,
            ["listid"] = listid,
            ["list_ver"] = 0,
            ["type"] = 0,
            ["slow_upload"] = 1,
            ["scene"] = "false;null",
            ["data"] = resourceArray
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/cloudlist.service/v6/add_song",
            Params = new Dictionary<string, string>
            {
                { "last_time", clientTime.ToString() },
                { "last_area", "gztx" },
                { "userid", userid },
                { "token", token }
            },
            Body = body,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     从歌单删除歌曲 (对应 /v4/delete_songs)
    /// </summary>
    /// <param name="fileIds">要删除的 FileId 列表 (注意不是 Hash，是歌单内的 fileid)</param>
    public async Task<JsonElement> RemoveSongsFromPlaylistAsync(
        string userid,
        string token,
        string listid,
        IEnumerable<long> fileIds)
    {
        // 构建 data 数组: [{fileid: 123}, {fileid: 456}]
        var resourceArray = new JsonArray();
        foreach (var fid in fileIds)
            resourceArray.Add(new JsonObject
            {
                ["fileid"] = fid
            });

        var body = new JsonObject
        {
            ["listid"] = listid,
            ["userid"] = userid,
            ["data"] = resourceArray,
            ["type"] = 0,
            ["token"] = token,
            ["list_ver"] = 0
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/v4/delete_songs",
            Body = body,
            SpecificRouter = "cloudlist.service.kugou.com",
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }
}using System.Text.Json;
using System.Text.Json.Nodes;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;

namespace KuGou.Net.Protocol.Raw;

public class RawRankApi(IKgTransport transport)
{
    /// <summary>
    ///     获取排行榜音乐列表
    /// </summary>
    public async Task<JsonElement> GetRankAudioAsync(int rankId, int? rankCid = null, int? page = null,
        int? pageSize = null)
    {
        var body = new JsonObject
        {
            ["show_portrait_mv"] = 1,
            ["show_type_total"] = 1,
            ["filter_original_remarks"] = 1,
            ["area_code"] = 1,
            ["pagesize"] = pageSize ?? 30,
            ["rank_cid"] = rankCid ?? 0,
            ["type"] = 1,
            ["page"] = page ?? 1,
            ["rank_id"] = rankId
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/openapi/kmr/v2/rank/audio",
            Body = body,
            SignatureType = SignatureType.Default,
            CustomHeaders = new Dictionary<string, string>
            {
                { "kg-tid", "369" }
            }
        };
        return await transport.SendAsync(request);
    }
    

    /// <summary>
    ///     获取排行榜列表
    /// </summary>
    public async Task<JsonElement> GetRankListAsync(int? withsong = null)
    {
        var body = new JsonObject
        {
            ["plat"] = 2,
            ["withsong"] = withsong ?? 1,
            ["parentid"] = 0
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            Path = "/ocean/v6/rank/list",
            Body = body,
            SignatureType = SignatureType.Default
        };
        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取排行榜推荐列表
    /// </summary>
    public async Task<JsonElement> GetRankTopAsync()
    {
        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            Path = "/mobileservice/api/v5/rank/rec_rank_list",
            SignatureType = SignatureType.Default
        };
        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取排行榜往期列表
    /// </summary>
    public async Task<JsonElement> GetRankVolAsync(int rankId, int? rankCid = null)
    {
        var body = new JsonObject
        {
            ["rank_cid"] = rankCid ?? 0,
            ["rank_id"] = rankId,
            ["ranktype"] = 0,
            ["type"] = 0,
            ["plat"] = 2
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            Path = "/ocean/v6/rank/vol",
            Body = body,
            SignatureType = SignatureType.Default
        };
        return await transport.SendAsync(request);
    }

    
    
}using System.Text.Json;
using System.Text.Json.Nodes;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Protocol.Raw;

/// <summary>
///     原始搜索接口 (对应原来的 SearchService)
/// </summary>
public class RawSearchApi(IKgTransport transport)
{
    // 对应: /v3/search/song
    public async Task<JsonElement> SearchSongAsync(string keyword, int page = 1, int pageSize = 30)
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "keyword", keyword },
            { "page", page.ToString() },
            { "pagesize", pageSize.ToString() },
            { "platform", "AndroidFilter" },
            { "iscorrection", "1" }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            Path = "/v3/search/song",
            Params = paramsDict,
            SpecificRouter = "complexsearch.kugou.com",
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    // 获取播放链接
    public async Task<JsonElement> GetPlayUrlAsync(string hash, string? quality = "128")
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "album_id", "0" },
            { "area_code", "1" },
            { "hash", hash.ToLower() },
            { "ssa_flag", "is_fromtrack" },
            { "version", KuGouConfig.Version },
            { "page_id", "967177915" },
            { "quality", quality ?? "128" },
            { "album_audio_id", "0" },
            { "behavior", "play" },
            { "pid", "411" },
            { "cmd", "26" },
            { "pidversion", "3001" },
            { "IsFreePart", "0" },
            { "ppage_id", "356753938,823673182,967485191" },
            { "cdnBackup", "1" },
            { "kcard", "0" },
            { "module", "" }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            Path = "/v5/url",
            Params = paramsDict,
            SpecificRouter = "trackercdn.kugou.com",
            SignatureType = SignatureType.V5,
            SpecificDfid = Guid.NewGuid().ToString("N")[..24]
        };

        return await transport.SendAsync(request);
    }


    //获取热搜
    public async Task<JsonElement> SearchHotAsync()
    {
        var paramsDict = new Dictionary<string, string>
        {
            { "navid", "1" },
            { "plat", "2" }
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            Path = "/api/v3/search/hot_tab",
            Params = paramsDict,
            SpecificRouter = "msearch.kugou.com",
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }


    public async Task<JsonElement> GetSingerSongsAsync(
        string dfid,
        string authorId,
        int page = 1,
        int pageSize = 30,
        string sort = "new")
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

        // 1. 计算特殊 Key: md5(appid + salt + clientver + time)
        var keyRaw = $"{KuGouConfig.AppId}{KuGouConfig.LiteSalt}{KuGouConfig.ClientVer}{clientTime}";
        var key = KgUtils.Md5(keyRaw);
        var mid = KgUtils.CalcNewMid(dfid);

        var body = new JsonObject
        {
            ["appid"] = KuGouConfig.AppId,
            ["clientver"] = KuGouConfig.ClientVer,
            ["mid"] = mid,
            ["clienttime"] = clientTime,
            ["key"] = key,
            ["author_id"] = authorId,
            ["pagesize"] = pageSize,
            ["page"] = page,
            ["sort"] = sort == "hot" ? 1 : 2, // 1：最热，2：最新
            ["area_code"] = "all"
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            BaseUrl = "https://openapi.kugou.com",
            Path = "/kmr/v1/audio_group/author",
            Body = body,
            SpecificRouter = "openapi.kugou.com",
            SignatureType = SignatureType.Default,

            CustomHeaders = new Dictionary<string, string>
            {
                { "kg-tid", "220" }
            }
        };

        return await transport.SendAsync(request);
    }
}using System.Text.Json;
using System.Text.Json.Nodes;
using KuGou.Net.Infrastructure.Http;
using KuGou.Net.Protocol.Transport;
using KuGou.Net.util;

namespace KuGou.Net.Protocol.Raw;

public class RawUserApi(IKgTransport transport)
{
    /// <summary>
    ///     获取用户详细信息 (对应 /v3/get_my_info)
    /// </summary>
    public async Task<JsonElement> GetUserDetailAsync(string userid, string token)
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

        var pkPayload = new JsonObject
        {
            ["token"] = token,
            ["clienttime"] = clientTime
        };
        var pk = KgCrypto.RsaEncryptNoPadding(JsonSerializer.Serialize(pkPayload, AppJsonContext.Default.JsonObject))
            .ToUpper();

        var body = new JsonObject
        {
            ["visit_time"] = clientTime,
            ["usertype"] = 1,
            ["p"] = pk,
            ["userid"] = long.Parse(userid)
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            BaseUrl = "https://gateway.kugou.com",
            Path = "/v3/get_my_info",
            Params = new Dictionary<string, string> { { "plat", "1" }, { "clienttime", clientTime.ToString() } },
            Body = body,
            SpecificRouter = "usercenter.kugou.com",
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取 VIP 信息 (对应 /v1/get_union_vip)
    /// </summary>
    public async Task<JsonElement> GetUserVipDetailAsync()
    {
        var request = new KgRequest
        {
            Method = HttpMethod.Get,
            BaseUrl = "https://kugouvip.kugou.com",
            Path = "/v1/get_union_vip",
            Params = new Dictionary<string, string> { { "busi_type", "concept" } },
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取用户歌单 (对应 /v7/get_all_list)
    /// </summary>
    public async Task<JsonElement> GetAllListAsync(string userid, string token, int page, int pageSize)
    {
        var body = new JsonObject
        {
            ["userid"] = userid,
            ["token"] = token,
            ["total_ver"] = 979,
            ["type"] = 2,
            ["page"] = page,
            ["pagesize"] = pageSize
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/v7/get_all_list",
            Params = new Dictionary<string, string>
            {
                { "plat", "1" },
                { "userid", userid },
                { "token", token }
            },
            Body = body,
            SpecificRouter = "cloudlist.service.kugou.com",
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取听歌历史 (对应 /playhistory/v1/get_songs)
    /// </summary>
    public async Task<JsonElement> GetPlayHistoryAsync(string userid, string token, string? bp = null)
    {
        var body = new JsonObject
        {
            ["token"] = token,
            ["userid"] = userid,
            ["source_classify"] = "app",
            ["to_subdivide_sr"] = 1
        };

        if (!string.IsNullOrEmpty(bp)) body["bp"] = bp;

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/playhistory/v1/get_songs",
            Body = body,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取听歌排行 (对应 /v2/get_list)
    /// </summary>
    public async Task<JsonElement> GetListenListAsync(string userid, string token, int type)
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();
        var pkPayload = new JsonObject
        {
            ["clienttime"] = clientTime,
            ["token"] = token
        };
        var p = KgCrypto.RsaEncryptNoPadding(JsonSerializer.Serialize(pkPayload, AppJsonContext.Default.JsonObject))
            .ToUpper();

        var body = new JsonObject
        {
            ["t_userid"] = userid,
            ["userid"] = userid,
            ["list_type"] = type,
            ["area_code"] = 1,
            ["cover"] = 2,
            ["p"] = p
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            BaseUrl = "https://listenservice.kugou.com",
            Path = "/v2/get_list",
            Params = new Dictionary<string, string> { { "plat", "0" } },
            Body = body,
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     获取关注歌手 (对应 /v4/follow_list)
    /// </summary>
    public async Task<JsonElement> GetFollowSingerListAsync(string userid, string token)
    {
        var clientTime = DateTimeOffset.UtcNow.ToUnixTimeSeconds();

        var pkPayload = new JsonObject
        {
            ["clienttime"] = clientTime,
            ["token"] = token
        };
        var p = KgCrypto.RsaEncryptNoPadding(JsonSerializer.Serialize(pkPayload, AppJsonContext.Default.JsonObject))
            .ToUpper();

        var body = new JsonObject
        {
            ["merge"] = 2,
            ["need_iden_type"] = 1,
            ["ext_params"] = "k_pic,jumptype,singerid,score",
            ["userid"] = userid,
            ["type"] = 0,
            ["id_type"] = 0,
            ["p"] = p
        };

        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/v4/follow_list",
            Params = new Dictionary<string, string> { { "plat", "1" } },
            Body = body,
            SpecificRouter = "relationuser.kugou.com",
            SignatureType = SignatureType.Default
        };

        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     领取一天 VIP
    /// </summary>
    public async Task<JsonElement> GetOneDayVipAsync()
    {
        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/youth/v1/recharge/receive_vip_listen_song",
            Params = new Dictionary<string, string> { { "source_id", "90137" } },
            SignatureType = SignatureType.Default
        };
        return await transport.SendAsync(request);
    }

    /// <summary>
    ///     升级 VIP
    /// </summary>
    public async Task<JsonElement> UpgradeVipAsync(string userid)
    {
        var request = new KgRequest
        {
            Method = HttpMethod.Post,
            Path = "/youth/v1/listen_song/upgrade_vip_reward",
            Params = new Dictionary<string, string>
            {
                { "kugouid", userid },
                { "ad_type", "1" }
            },
            SignatureType = SignatureType.Default
        };
        return await transport.SendAsync(request);
    }
}namespace KuGou.Net.Protocol.Session;

public class KgSession
{
    public string UserId { get; set; } = "0";
    public string Token { get; set; } = "";
    public string VipType { get; set; } = "0";
    public string VipToken { get; set; } = "";
    public string Dfid { get; set; } = "-";
    public string Mid { get; set; } = "-";
    public string Uuid { get; set; } = "-";
}using System.Net;
using KuGou.Net.util;

// 引用你原来的工具类

namespace KuGou.Net.Protocol.Session;

public class KgSessionManager
{
    private readonly CookieContainer _cookieContainer;

    public KgSessionManager(CookieContainer cookieContainer)
    {
        _cookieContainer = cookieContainer;
        Session = KgSessionStore.Load() ?? new KgSession();

        if (Session.Dfid == "-" || string.IsNullOrEmpty(Session.Dfid))
        {
            Session.Dfid = KuGouConfig.Dfid;
            Session.Mid = KgUtils.CalcNewMid(Session.Dfid);
            Session.Uuid = KgUtils.Md5(Session.Dfid + Session.Mid);
        }

        SyncCookies();
    }

    public KgSession Session { get; }

    public void UpdateAuth(string userId, string token, string vipType, string vipToken)
    {
        Session.UserId = userId;
        Session.Token = token;
        Session.VipType = vipType;
        Session.VipToken = vipToken;

        KgSessionStore.Save(Session);
        SyncCookies();
    }

    private void SyncCookies()
    {
        SetCookie("userid", Session.UserId);
        SetCookie("token", Session.Token);
        SetCookie("vip_type", Session.VipType);
        SetCookie("vip_token", Session.VipToken);
    }

    private void SetCookie(string name, string value)
    {
        if (string.IsNullOrEmpty(name)) return;
        var domains = new[] { "kugou.com", "login-user.kugou.com", "gateway.kugou.com" };
        foreach (var domain in domains)
            try
            {
                _cookieContainer.Add(new Cookie(name, value ?? "", "/", domain));
            }
            catch
            {
            }
    }
}using System.Text.Json;
using KuGou.Net.util;

namespace KuGou.Net.Protocol.Session;

public static class KgSessionStore
{
    private static readonly string FilePath =
        Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
            "kugou",
            "session.json"
        );
    

    public static void Save(KgSession session)
    {
        // 1. 确保目录存在 (修复路径不存在报错)
        var dir = Path.GetDirectoryName(FilePath);
        if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir)) Directory.CreateDirectory(dir);

        // 2. 使用 Source Generator 进行序列化
        // 传入 _writeOptions.KgSession 代替反射
        var json = JsonSerializer.Serialize(session, AppJsonContext.Default.KgSession);

        File.WriteAllText(FilePath, json);
    }

    public static KgSession? Load()
    {
        if (!File.Exists(FilePath)) return null;

        try
        {
            var json = File.ReadAllText(FilePath);
            // 3. 使用 Source Generator 进行反序列化
            // 传入 KuGouJsonContext.Default.KgSession (读取不需要缩进配置，用默认即可)
            return JsonSerializer.Deserialize(json, AppJsonContext.Default.KgSession);
        }
        catch
        {
            // 防止文件损坏导致程序崩溃
            return null;
        }
    }

    public static void Clear()
    {
        if (File.Exists(FilePath)) File.Delete(FilePath);
    }
}using System.Text.Json.Nodes;

namespace KuGou.Net.Protocol.Transport;

public enum SignatureType
{
    Default, // V3/V4 常规签名
    V5, // V5 获取播放链接专用
    Web, // 扫码登录等 Web 接口
    None // 不签名
}

public class KgRequest
{
    public HttpMethod Method { get; set; } = HttpMethod.Get;

    // API 路径，例如 "/v3/search/song"
    public required string Path { get; set; }

    // 基础参数
    public Dictionary<string, string> Params { get; set; } = new();

    // POST Body (如果是 GET 则忽略)
    public JsonObject? Body { get; set; }

    // 签名策略
    public SignatureType SignatureType { get; set; } = SignatureType.Default;

    // 指定路由 (x-router header)，例如 "complexsearch.kugou.com"
    public string? SpecificRouter { get; set; }

    // 覆盖用的 Dfid (很少用，但在 GetPlayUrlAsync 里用到了)
    public string? SpecificDfid { get; set; }

    // 指定 BaseUrl (如果不指定，默认走 gateway)
    public string? BaseUrl { get; set; }


    // 新增：支持原始字符串 Body (用于注册接口发送 Base64)
    public string? RawBody { get; set; }

    // 新增：自定义 Content-Type
    public string ContentType { get; set; } = "application/json";

    public Dictionary<string, string>? CustomHeaders { get; set; }
}using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using KuGou.Net.Abstractions.Models;
using KuGou.Net.Protocol.Session;

namespace KuGou.Net.util;

// 1. 开启源生成器模式
[JsonSourceGenerationOptions(
    WriteIndented = false,
    PropertyNamingPolicy = JsonKnownNamingPolicy.CamelCase,
    PropertyNameCaseInsensitive = true, // 允许忽略大小写
    NumberHandling = JsonNumberHandling.AllowReadingFromString // 允许字符串转数字
)]
// 2. 注册基础类型
[JsonSerializable(typeof(Dictionary<string, string>))]
[JsonSerializable(typeof(Dictionary<string, object>))]
[JsonSerializable(typeof(JsonElement))]
[JsonSerializable(typeof(JsonNode))]
[JsonSerializable(typeof(JsonObject))]
[JsonSerializable(typeof(JsonArray))]
[JsonSerializable(typeof(JsonValue))]
[JsonSerializable(typeof(List<string>))]
// 3. 注册 Session 相关
[JsonSerializable(typeof(KgSession))]
// 4. 注册所有 API 模型 (这是最重要的部分，漏掉会导致 AOT 报错)
[JsonSerializable(typeof(LoginResponse))]
[JsonSerializable(typeof(QrKeyResponse))]
[JsonSerializable(typeof(QrStatusResponse))]
[JsonSerializable(typeof(SendCodeResponse))]
[JsonSerializable(typeof(RefreshTokenResponse))]
[JsonSerializable(typeof(SearchResultData))]
[JsonSerializable(typeof(PlayUrlData))]
[JsonSerializable(typeof(PlaylistSongResponse))]
[JsonSerializable(typeof(PlaylistInfo))]
[JsonSerializable(typeof(List<PlaylistInfo>))] // 这种 List<T> 也要单独注册
[JsonSerializable(typeof(UserPlaylistResponse))]
[JsonSerializable(typeof(UserPlaylistItem))]
[JsonSerializable(typeof(List<UserPlaylistItem>))]
[JsonSerializable(typeof(LanguageContainer))]
[JsonSerializable(typeof(SearchHotResponse))]
[JsonSerializable(typeof(List<SearchHotCategory>))]
[JsonSerializable(typeof(List<SearchHotKeyword>))]
[JsonSerializable(typeof(UserVipResponse))]
[JsonSerializable(typeof(UserDetailModel))]
[JsonSerializable(typeof(OneDayVipModel))]
[JsonSerializable(typeof(UpgradeVipModel))]
[JsonSerializable(typeof(List<BusiVipInfo>))]
internal partial class AppJsonContext : JsonSerializerContext
{
}namespace KuGou.Net.util;

public static class Constants
{
    // 对应 JS 中的 publicRasKey
    public const string PublicRasKey = @"-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDIAG7QOELSYoIJvTFJhMpe1s/gbjDJX51HBNnEl5HXqTW6lQ7LC8jr9fWZTwusknp+sVGzwd40MwP6U5yDE27M/X1+UR4tvOGOqp94TJtQ1EPnWGWXngpeIW5GxoQGao1rmYWAu6oi1z9XkChrsUdC6DJE5E221wf/4WLFxwAtRQIDAQAB
-----END PUBLIC KEY-----";

    // 对应 JS 中的 publicLiteRasKey (概念版/Lite版)
    public const string PublicLiteRasKey = @"-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDECi0Np2UR87scwrvTr72L6oO01rBbbBPriSDFPxr3Z5syug0O24QyQO8bg27+0+4kBzTBTBOZ/WWU0WryL1JSXRTXLgFVxtzIY41Pe7lPOgsfTCn5kZcvKhYKJesKnnJDNr5/abvTGf+rHG3YRwsCHcQ08/q6ifSioBszvb3QiwIDAQAB
-----END PUBLIC KEY-----";
}using System.IO.Compression;
using System.Numerics;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;

namespace KuGou.Net.util;

public static class KgCrypto
{
    // ---------------- AES 部分 ----------------

    /// <summary>
    ///     AES 加密 (对应 cryptoAesEncrypt)
    /// </summary>
    /// <returns>返回 (HexStr, Key)</returns>
    public static (string str, string key) AesEncrypt(string data, string key = null, string iv = null)
    {
        var tempKey = key;
        string actualKeyStr;
        string actualIvStr;

        // 1. Key/IV 生成逻辑复刻 JS
        if (!string.IsNullOrEmpty(key) && !string.IsNullOrEmpty(iv))
        {
            actualKeyStr = key; // 这里假设传入的就是处理好的
            actualIvStr = iv;
        }
        else
        {
            tempKey = key ?? KgUtils.RandomString().ToLower();
            actualKeyStr = KgUtils.Md5(tempKey);
            actualIvStr = actualKeyStr.Substring(actualKeyStr.Length - 16);
        }

        // 2. 执行加密 (AES-256-CBC)
        // Node.js 的 createCipheriv 如果传入字符串，默认按 UTF8 编码处理
        var keyBytes = Encoding.UTF8.GetBytes(actualKeyStr); // 32 bytes
        var ivBytes = Encoding.UTF8.GetBytes(actualIvStr); // 16 bytes
        var dataBytes = Encoding.UTF8.GetBytes(data);

        using var aes = Aes.Create();
        aes.KeySize = 256;
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7; // Node 默认填充
        aes.Key = keyBytes;
        aes.IV = ivBytes;

        using var encryptor = aes.CreateEncryptor();
        var encryptedBytes = encryptor.TransformFinalBlock(dataBytes, 0, dataBytes.Length);

        return (Convert.ToHexString(encryptedBytes).ToLower(), tempKey);
    }

    /// <summary>
    ///     AES 解密 (对应 cryptoAesDecrypt)
    /// </summary>
    public static string AesDecrypt(string hexData, string key)
    {
        var actualKeyStr = KgUtils.Md5(key);
        var actualIvStr = actualKeyStr.Substring(actualKeyStr.Length - 16);

        var keyBytes = Encoding.UTF8.GetBytes(actualKeyStr);
        var ivBytes = Encoding.UTF8.GetBytes(actualIvStr);
        var encryptedBytes = Convert.FromHexString(hexData);

        using var aes = Aes.Create();
        aes.KeySize = 256;
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;
        aes.Key = keyBytes;
        aes.IV = ivBytes;

        using var decryptor = aes.CreateDecryptor();
        var decryptedBytes = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);

        return Encoding.UTF8.GetString(decryptedBytes);
    }

    // ---------------- RSA 部分 ----------------

    /// <summary>
    ///     RSA 加密 (对应 cryptoRSAEncrypt - 使用 NO_PADDING)
    /// </summary>
    public static string RsaEncryptNoPadding(string data, bool isLite = true)
    {
        var pem = isLite ? Constants.PublicLiteRasKey : Constants.PublicRasKey;
        var dataBytes = Encoding.UTF8.GetBytes(data);

        // ⚠️ 关键修复：先填充到 128 字节，然后再加密
        // JS: const _buffer = Buffer.concat([buffer, Buffer.alloc(128 - buffer.length)]);
        var paddedData = new byte[128];
        Array.Copy(dataBytes, 0, paddedData, 0, dataBytes.Length);
        // 剩余部分自动为 0，相当于 JS 的 Buffer.alloc(128 - buffer.length)

        using var rsa = RSA.Create();
        rsa.ImportFromPem(pem);
        var parameters = rsa.ExportParameters(false);

        // 1. 将填充后的数据转为 BigInteger (Big Endian, Unsigned)
        var m = new BigInteger(paddedData, true, true);

        var e = new BigInteger(parameters.Exponent!, true, true);
        var n = new BigInteger(parameters.Modulus!, true, true);

        // 2. 核心运算 c = m^e mod n
        var c = BigInteger.ModPow(m, e, n);

        // 3. 导出结果 (Big Endian)
        var resBytes = c.ToByteArray(true, true);

        // 4. 确保输出是 128 字节
        if (resBytes.Length < 128)
        {
            var temp = new byte[128];
            Array.Copy(resBytes, 0, temp, 128 - resBytes.Length, resBytes.Length);
            resBytes = temp;
        }
        else if (resBytes.Length > 128)
        {
            var temp = new byte[128];
            Array.Copy(resBytes, resBytes.Length - 128, temp, 0, 128);
            resBytes = temp;
        }

        return Convert.ToHexString(resBytes).ToLower();
    }

    /// <summary>
    ///     RSA 加密 (对应 rsaEncrypt2 - 使用 PKCS1_PADDING)
    /// </summary>
    public static string RsaEncryptPkcs1(string data, bool isLite = true)
    {
        var pem = isLite ? Constants.PublicLiteRasKey : Constants.PublicRasKey;
        // JS 中对 data 进行了 object -> json string 的判断，这里假设传入已序列化的 string
        var dataBytes = Encoding.UTF8.GetBytes(data);

        using var rsa = RSA.Create();
        rsa.ImportFromPem(pem);

        // 使用标准的 PKCS1 填充
        var encryptedBytes = rsa.Encrypt(dataBytes, RSAEncryptionPadding.Pkcs1);
        return Convert.ToHexString(encryptedBytes).ToLower();
    }

    public static (string str, string key) PlaylistAesEncrypt(object data)
    {
        var json = JsonSerializer.Serialize(data, KgUtils.JsonOptions);
        var key = KgUtils.RandomString(6).ToLower();

        // JS: md5(key).substring(0, 16)
        var md5Key = KgUtils.Md5(key);
        var encryptKey = md5Key.Substring(0, 16);
        var iv = md5Key.Substring(16, 16);

        using var aes = Aes.Create();
        aes.KeySize = 128;
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;
        aes.Key = Encoding.UTF8.GetBytes(encryptKey);
        aes.IV = Encoding.UTF8.GetBytes(iv);

        using var encryptor = aes.CreateEncryptor();
        var dataBytes = Encoding.UTF8.GetBytes(json);
        var encrypted = encryptor.TransformFinalBlock(dataBytes, 0, dataBytes.Length);

        // JS 返回 base64
        return (Convert.ToBase64String(encrypted), key);
    }


    public static string PlaylistAesDecrypt(string str, string key)
    {
        var md5Key = KgUtils.Md5(key);
        var encryptKey = md5Key.Substring(0, 16);
        var iv = md5Key.Substring(16, 16);

        using var aes = Aes.Create();
        aes.KeySize = 128;
        aes.Mode = CipherMode.CBC;
        aes.Padding = PaddingMode.PKCS7;
        aes.Key = Encoding.UTF8.GetBytes(encryptKey);
        aes.IV = Encoding.UTF8.GetBytes(iv);

        using var decryptor = aes.CreateDecryptor();
        var encryptedBytes = Convert.FromBase64String(str);
        var decrypted = decryptor.TransformFinalBlock(encryptedBytes, 0, encryptedBytes.Length);

        return Encoding.UTF8.GetString(decrypted);
    }

    public static string DecodeLyrics(string base64Str)
    {
        if (string.IsNullOrEmpty(base64Str)) return "";
        var bytes = Convert.FromBase64String(base64Str);
        if (bytes.Length <= 4) return "";

        // 1. 异或解密
        byte[] enKey = { 64, 71, 97, 119, 94, 50, 116, 71, 81, 54, 49, 45, 206, 210, 110, 105 };
        // JS: const krcBytes = bytes.slice(4);
        var krcBytes = new byte[bytes.Length - 4];
        Array.Copy(bytes, 4, krcBytes, 0, krcBytes.Length);

        for (var i = 0; i < krcBytes.Length; i++) krcBytes[i] = (byte)(krcBytes[i] ^ enKey[i % enKey.Length]);

        // 2. 解压 (zlib inflate)
        // JS pako.inflate 对应 ZLib。
        // .NET 的 DeflateStream 无法直接解压带 ZLib 头的流 (0x78 0x9C 等)，需要跳过头 2 字节
        // 或者使用 System.IO.Compression.ZLibStream (.NET 6+)
        try
        {
            using var msInput = new MemoryStream(krcBytes);
            // ZLibStream 自动处理 Header
            using var zlib = new ZLibStream(msInput, CompressionMode.Decompress);
            using var msOutput = new MemoryStream();
            zlib.CopyTo(msOutput);
            return Encoding.UTF8.GetString(msOutput.ToArray());
        }
        catch
        {
            return "";
        }
    }
}using System.Text;

namespace KuGou.Net.util;

public static class KgSigner
{
    public static string CalcV5Key(string hash, string userid, string mid)
    {
        var salt = KuGouConfig.V5KeySalt;

        var raw = $"{hash}{salt}{KuGouConfig.AppId}{mid}{userid}";
        return KgUtils.Md5(raw);
    }

    public static string CalcSignature(Dictionary<string, string> paramsDict)
    {
        return CalcPostSignature(paramsDict, string.Empty);
    }

    public static string CalcPostSignature(Dictionary<string, string> queryParams, string jsonBody)
    {
        var sb = new StringBuilder();
        var salt = KuGouConfig.LiteSalt;

        sb.Append(salt);

        // 既然 kv.Value 肯定是 string，直接 Append 即可，不需要判断类型，也不需要序列化
        foreach (var kv in queryParams.OrderBy(x => x.Key, StringComparer.Ordinal))
        {
            sb.Append(kv.Key);
            sb.Append('=');
            sb.Append(kv.Value);
        }

        if (!string.IsNullOrEmpty(jsonBody)) sb.Append(jsonBody);

        sb.Append(salt);

        return KgUtils.Md5(sb.ToString());
    }

    public static string CalcLoginKey(long clienttimeMs)
    {
        var salt = KuGouConfig.LiteSalt;
        var raw = $"{KuGouConfig.AppId}{salt}{KuGouConfig.ClientVer}{clienttimeMs}";
        return KgUtils.Md5(raw);
    }

    public static string CalcWebQrSignature(Dictionary<string, string> paramsDict)
    {
        var sb = new StringBuilder();
        const string webSalt = KuGouConfig.WebSignatureSalt;

        sb.Append(webSalt);

        foreach (var kv in paramsDict.OrderBy(x => x.Key, StringComparer.Ordinal))
        {
            sb.Append(kv.Key);
            sb.Append('=');
            sb.Append(kv.Value);
        }

        sb.Append(webSalt);

        return KgUtils.Md5(sb.ToString());
    }
}using System.Security.Cryptography;
using System.Text;
using System.Text.Encodings.Web;
using System.Text.Json;

namespace KuGou.Net.util;

public static class KgUtils
{
    public static readonly JsonSerializerOptions JsonOptions = new()
    {
        Encoder = JavaScriptEncoder.UnsafeRelaxedJsonEscaping,
        WriteIndented = false,
        TypeInfoResolver = AppJsonContext.Default
    };

    /// <summary>
    ///     生成指定长度的随机字符串 (对应 randomString)
    /// </summary>
    public static string RandomString(int length = 16)
    {
        const string chars = "1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        var sb = new StringBuilder(length);
        var rnd = Random.Shared;
        for (var i = 0; i < length; i++) sb.Append(chars[rnd.Next(chars.Length)]);
        return sb.ToString();
    }

    /// <summary>
    ///     MD5 加密，返回小写 Hex 字符串 (对应 cryptoMd5)
    /// </summary>
    public static string Md5(string input)
    {
        if (string.IsNullOrEmpty(input)) return "";
        var bytes = Encoding.UTF8.GetBytes(input);
        var hash = MD5.HashData(bytes);
        return Convert.ToHexString(hash).ToLower();
    }

    /// <summary>
    ///     MD5 加密，输入为 bytes (辅助方法)
    /// </summary>
    public static string Md5(byte[] input)
    {
        var hash = MD5.HashData(input);
        return Convert.ToHexString(hash).ToLower();
    }

    public static string CalcNewMid(string dfid)
    {
        // 对应 JS: const mid = cryptoMd5(dfid); (注意 JS 如果 dfid 是 '-', md5也是固定的)
        var md5 = Md5(dfid);

        // 对应 JS: `${mid}${mid.slice(0, 7)}`
        return $"{md5}{md5.Substring(0, 7)}";
    }
}namespace KuGou.Net.util;

public static class KuGouConfig
{
    // ================= 身份标识 (Lite版) =================
    public const string AppId = "3116";
    public const string ClientVer = "11436";
    public const string Version = "11436";
    public const string UserAgent = "Android15-1070-11083-46-0-DiscoveryDRADProtocol-wifi";

    // ================= 盐值 (Lite版) =================
    // 用于计算 Key (v5接口)
    public const string V5KeySalt = "185672dd44712f60bb1736df5a377e82";

    // 用于计算 Signature (通用)
    public const string LiteSalt = "LnT6xpN3khm36zse0QzvmgTZ3waWdRSA";

    // ================= 设备指纹 (建议持久化，这里暂时写死) =================
    public const string Dfid = "-";
    public const string Mid = "336d5ebc5436534e61d16e63ddfca327";
    public const string Uuid = "15e772e1213bdd0718d0c1d10d64e06f";


    public const string WebSignatureSalt = "NVPh5oo715z5DIWAeQlhMDsWXXQV4hwt";
}